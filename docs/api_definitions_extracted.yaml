# Auto-extracted API definitions from C++ bindings
# Generated by docs/extract_api.py
# Documentation filled in based on Binary Ninja API semantics

BasicBlock:
  description: |
    Represents a basic block within a function - a sequence of instructions with a single entry and exit point. Basic blocks are fundamental units of control flow analysis.
  properties:
    start_addr:
      type: HexAddress
      description: Starting address of the basic block
      example: |
        for _, block in ipairs(func:basic_blocks()) do
            print("Block starts at:", block.start_addr)
        end
    end_addr:
      type: HexAddress
      description: Ending address of the basic block (exclusive)
      example: |
        local block = func:basic_blocks()[1]
        print("Block range:", block.start_addr, "to", block.end_addr)
    length:
      type: integer
      description: Size of the basic block in bytes
      example: |
        local total = 0
        for _, block in ipairs(func:basic_blocks()) do
            total = total + block.length
        end
        print("Total code size:", total)
    index:
      type: integer
      description: Index of the basic block within the function
      example: |
        local block = func:basic_blocks()[1]
        print("Block index:", block.index)
    function:
      type: Function
      description: The function containing this basic block
      example: |
        local parent = block.function
        print("Block belongs to:", parent.name)
    arch:
      type: string
      description: Architecture name for this basic block
      example: print("Block architecture:", block.arch)
    can_exit:
      type: boolean
      description: Whether this block can cause the function to return
      example: |
        for _, block in ipairs(func:basic_blocks()) do
            if block.can_exit then
                print("Exit block at:", block.start_addr)
            end
        end
    has_undetermined_outgoing_edges:
      type: boolean
      description: Whether the block has unresolved indirect branches
      example: |
        if block.has_undetermined_outgoing_edges then
            print("Warning: indirect branch at", block.start_addr)
        end
    has_invalid_instructions:
      type: boolean
      description: Whether the block contains invalid or unrecognized instructions
    is_il:
      type: boolean
      description: Whether this is an IL (Intermediate Language) basic block
    is_llil:
      type: boolean
      description: Whether this is a Low Level IL basic block
    is_mlil:
      type: boolean
      description: Whether this is a Medium Level IL basic block
  methods:
    instruction_count:
      description: Get the number of instructions in this basic block
      returns: integer
      example: |
        for _, block in ipairs(func:basic_blocks()) do
            print(block.start_addr, "has", block:instruction_count(), "instructions")
        end
    outgoing_edges:
      description: Get all outgoing edges from this basic block
      returns: table
      example: |
        local edges = block:outgoing_edges()
        print("Block has", #edges, "outgoing edges")
        for _, edge in ipairs(edges) do
            print("  ->", edge.target.start_addr, "(", edge.type, ")")
        end
    incoming_edges:
      description: Get all incoming edges to this basic block
      returns: table
      example: |
        local edges = block:incoming_edges()
        print("Block has", #edges, "predecessors")
    dominators:
      description: Get all basic blocks that dominate this block
      returns: table
      example: |
        local doms = block:dominators()
        print("Dominated by", #doms, "blocks")
    strict_dominators:
      description: Get all basic blocks that strictly dominate this block (excluding itself)
      returns: table
    immediate_dominator:
      description: Get the immediate dominator of this basic block
      returns: BasicBlock
      example: |
        local idom = block:immediate_dominator()
        if idom then print("Immediate dominator:", idom.start_addr) end
    dominator_tree_children:
      description: Get the children of this block in the dominator tree
      returns: table
    dominance_frontier:
      description: Get the dominance frontier of this basic block
      returns: table
    post_dominators:
      description: Get all basic blocks that post-dominate this block
      returns: table
    strict_post_dominators:
      description: Get all basic blocks that strictly post-dominate this block
      returns: table
    immediate_post_dominator:
      description: Get the immediate post-dominator of this basic block
      returns: BasicBlock
    post_dominator_tree_children:
      description: Get the children of this block in the post-dominator tree
      returns: table
    post_dominance_frontier:
      description: Get the post-dominance frontier of this basic block
      returns: table
    dominates:
      description: Check if this block dominates another block
      returns: boolean
      example: |
        local entry = func:basic_blocks()[1]
        for _, block in ipairs(func:basic_blocks()) do
            if entry:dominates(block) then
                print("Entry dominates block at", block.start_addr)
            end
        end
    strictly_dominates:
      description: Check if this block strictly dominates another block
      returns: boolean
    post_dominates:
      description: Check if this block post-dominates another block
      returns: boolean
    disassembly_text:
      description: Get formatted disassembly text lines for this block
      returns: table
      example: |
        for _, line in ipairs(block:disassembly_text()) do
            print(line)
        end
    disassembly:
      description: Get raw disassembly for this block
      returns: table
    instructions:
      description: Get all instructions in this basic block
      returns: table
      example: |
        for _, instr in ipairs(block:instructions()) do
            print(instr.address, instr.text)
        end

BinaryView:
  description: |
    Primary interface for analyzing a binary - provides access to functions, data, types, and analysis operations. Available as the 'bv' magic variable.
  properties:
    start_addr:
      type: HexAddress
      description: Starting address of the binary view
      example: print("Binary starts at:", bv.start_addr)
      aliases:
      - start
    start:
      type: HexAddress
      description: Alias for start_addr
    end_addr:
      type: HexAddress
      description: Ending address of the binary view
      example: print("Binary ends at:", bv.end_addr)
      aliases:
      - end
    end:
      type: HexAddress
      description: Alias for end_addr (use bv["end"] since 'end' is a Lua keyword)
    length:
      type: integer
      description: Total size of the binary view in bytes
      example: print("Size:", bv.length, "bytes")
    file:
      type: string
      description: Full path to the binary file
      example: print("File:", bv.file)
      aliases:
      - filename
    filename:
      type: string
      description: Name of the binary file without path
    arch:
      type: string
      description: Architecture name (e.g., "x86_64", "arm")
      example: print("Architecture:", bv.arch)
    entry_point:
      type: HexAddress
      description: Entry point address of the binary
      example: |
        local entry_func = bv:get_function_at(bv.entry_point)
        if entry_func then print("Entry:", entry_func.name) end
    has_data_vars:
      type: boolean
      description: Whether the binary has any defined data variables
      example: |
        if bv.has_data_vars then
            print("Data variables:", #bv:data_vars())
        end
  methods:
    functions:
      description: Get all functions in the binary
      returns: table
      example: |
        local funcs = bv:functions()
        print("Found", #funcs, "functions")
        for i = 1, math.min(5, #funcs) do
            print(funcs[i].name)
        end
    sections:
      description: Get all sections in the binary
      returns: table
      example: |
        for _, section in ipairs(bv:sections()) do
            print(section.name, section.start_addr, section.length)
        end
    strings:
      description: Get all detected strings in the binary
      returns: table
      example: |
        for _, s in ipairs(bv:strings()) do
            if #s.value > 5 then
                print(s.addr, s.value)
            end
        end
    imports:
      description: Get all imported symbols
      returns: table
      example: |
        for _, imp in ipairs(bv:imports()) do
            print(imp.short_name, "@", imp.address)
        end
    exports:
      description: Get all exported symbols
      returns: table
      example: |
        for _, exp in ipairs(bv:exports()) do
            print(exp.short_name, "@", exp.address)
        end
    data_vars:
      description: Get all defined data variables
      returns: table
      example: |
        for _, var in ipairs(bv:data_vars()) do
            print(var.address, var.name or "<unnamed>", var.type)
        end
    get_function_at:
      description: Get the function starting at the specified address
      returns: Function
      params:
      - name: addr
        type: HexAddress|integer
        description: Address as HexAddress or integer
      example: |
        local func = bv:get_function_at(0x401000)
        if func then print("Found:", func.name) end
    get_data_var_at:
      description: Get the data variable at the specified address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Address to look up
      example: |
        local var = bv:get_data_var_at(0x404000)
        if var then print(var.type) end
    define_data_var:
      description: Define a data variable at an address with a type
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address for the data variable
      - name: typeStr
        type: string
        description: Type string (e.g., "int", "char*")
      - name: name
        type: string
        description: Optional name for the variable
      example: |
        bv:define_data_var(0x404000, "int32_t", "g_counter")
    define_user_data_var:
      description: Define a user data variable (persisted in database)
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Address for the data variable
      - name: typeStr
        type: string
        description: Type string for the variable
      - name: name
        type: string
        description: Optional name for the variable
      example: |
        local var = bv:define_user_data_var(0x404000, "uint64_t", "counter")
        if var then print("Created:", var.name) end
    undefine_data_var:
      description: Remove a data variable definition
      params:
      - name: addr
        type: integer
        description: Address of the data variable to remove
    undefine_user_data_var:
      description: Remove a user-defined data variable
      params:
      - name: addr
        type: integer
        description: Address of the data variable to remove
    get_next_data_var_after:
      description: Get the next data variable after the given address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Starting address
      example: |
        local var = bv:get_next_data_var_after(here.value)
        if var then print("Next var at:", var.address) end
    get_previous_data_var_before:
      description: Get the previous data variable before the given address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Starting address
    get_next_function_start_after:
      description: Get the start address of the next function after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
      example: |
        local next_addr = bv:get_next_function_start_after(here)
        if next_addr then print("Next function at:", next_addr) end
    get_previous_function_start_before:
      description: Get the start address of the previous function before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_next_basic_block_start_after:
      description: Get the start of the next basic block after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_previous_basic_block_start_before:
      description: Get the start of the previous basic block before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_next_data_after:
      description: Get the address of the next data item after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_previous_data_before:
      description: Get the address of the previous data item before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_functions_at:
      description: Get all functions that start at the given address
      returns: table
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to query
    get_functions_containing:
      description: Get all functions that contain the given address
      returns: table
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to query
      example: |
        local funcs = bv:get_functions_containing(here)
        for _, f in ipairs(funcs) do
            print("Address is in:", f.name)
        end
    get_basic_blocks_starting_at:
      description: Get all basic blocks starting at the given address
      returns: table
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to query
    get_functions_by_name:
      description: Find functions by name
      returns: table
      params:
      - name: name
        type: string
        description: Function name or pattern to search for
      - name: exact
        type: boolean
        description: Whether to require exact match (default false)
      example: |
        local main_funcs = bv:get_functions_by_name("main")
        for _, f in ipairs(main_funcs) do
            print(f.name, f.start_addr)
        end
    find_next_data:
      description: Search for byte pattern starting from an address
      returns: HexAddress|nil
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address for search
      - name: data
        type: string
        description: Byte pattern to search for
      example: |
        local addr = bv:find_next_data(bv.start, "\x90\x90\x90")
        if addr then print("NOP sled at:", addr) end
    find_all_data:
      description: Find all occurrences of a byte pattern in a range
      returns: table
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address
      - name: end_addr
        type: HexAddress|integer
        description: Ending address
      - name: data
        type: string
        description: Byte pattern to search for
      example: |
        local matches = bv:find_all_data(bv.start, bv["end"], "\xCC")
        print("Found", #matches, "breakpoints")
    find_next_text:
      description: Search for text pattern in disassembly
      returns: any
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address
      - name: pattern
        type: string
        description: Text pattern to search for
    find_all_text:
      description: Find all text pattern matches in a range
      returns: table
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address
      - name: end_addr
        type: HexAddress|integer
        description: Ending address
      - name: pattern
        type: string
        description: Text pattern to search for
    find_next_constant:
      description: Find the next use of a constant value
      returns: HexAddress|nil
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address
      - name: constant
        type: integer
        description: Constant value to search for
      example: |
        -- Find uses of 0xDEADBEEF
        local addr = bv:find_next_constant(bv.start, 0xDEADBEEF)
    read:
      description: Read raw bytes from the binary
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to read from
      - name: len
        type: integer
        description: Number of bytes to read
      example: |
        local bytes = bv:read(func.start_addr.value, 16)
        print("First 16 bytes:", bytes:gsub(".", function(c)
            return string.format("%02X ", c:byte())
        end))
    get_code_refs:
      description: Get all code references to an address
      returns: table
      params:
      - name: addr
        type: integer
        description: Target address
      example: |
        local refs = bv:get_code_refs(func.start_addr.value)
        print("Called from", #refs, "locations")
    get_data_refs:
      description: Get all data references to an address
      returns: table
      params:
      - name: addr
        type: integer
        description: Target address
    get_code_refs_from:
      description: Get all code references from an address
      returns: table
      params:
      - name: addr
        type: integer
        description: Source address
    get_data_refs_from:
      description: Get all data references from an address
      returns: table
      params:
      - name: addr
        type: integer
        description: Source address
    get_callers:
      description: Get all addresses that call the given address
      returns: table
      params:
      - name: addr
        type: integer
        description: Target address
    get_callees:
      description: Get all addresses called from the given address
      returns: table
      params:
      - name: addr
        type: integer
        description: Source address
    comment_at_address:
      description: Get the comment at an address
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to query
      example: |
        local comment = bv:comment_at_address(here.value)
        if comment ~= "" then print("Comment:", comment) end
    set_comment_at_address:
      description: Set a comment at an address
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address for the comment
      - name: comment
        type: string
        description: Comment text
      example: |
        bv:set_comment_at_address(here.value, "Important location")
    tag_types:
      description: Get all tag types defined in the binary
      returns: table
      example: |
        for _, tt in ipairs(bv:tag_types()) do
            print(tt.icon, tt.name)
        end
    get_tag_type:
      description: Get a tag type by name
      returns: TagType
      params:
      - name: name
        type: string
        description: Name of the tag type
    create_tag_type:
      description: Create a new tag type
      returns: TagType
      params:
      - name: name
        type: string
        description: Name for the tag type
      - name: icon
        type: string
        description: Icon emoji for the tag type
      example: |
        local bug_type = bv:create_tag_type("Bug", "!")
    remove_tag_type:
      description: Remove a tag type from the binary
      params:
      - name: tagType
        type: TagType
        description: Tag type to remove
    get_tags_at:
      description: Get all tags at an address
      returns: table
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to query
      example: |
        local tags = bv:get_tags_at(here)
        for _, tag in ipairs(tags) do
            print(tag.type.icon, tag.data)
        end
    add_tag:
      description: Add a tag at an address
      params:
      - name: addr
        type: HexAddress|integer
        description: Address for the tag
      - name: tag
        type: Tag
        description: Tag to add
      - name: user
        type: boolean
        description: Whether this is a user tag (default true)
    remove_tag:
      description: Remove a tag from an address
      params:
      - name: addr
        type: HexAddress|integer
        description: Address of the tag
      - name: tag
        type: Tag
        description: Tag to remove
      - name: user
        type: boolean
        description: Whether this is a user tag
    create_user_tag:
      description: Create and add a user tag at an address
      returns: Tag
      params:
      - name: addr
        type: HexAddress|integer
        description: Address for the tag
      - name: tagTypeName
        type: string
        description: Name of the tag type
      - name: data
        type: string
        description: Tag data/content
      example: |
        bv:create_user_tag(here, "Bug", "Potential buffer overflow")
    get_all_tags:
      description: Get all tags in the binary
      returns: table
    get_tags_of_type:
      description: Get all tags of a specific type
      returns: table
      params:
      - name: tagType
        type: TagType
        description: Tag type to filter by
    get_tags_in_range:
      description: Get all tags within an address range
      returns: table
      params:
      - name: start
        type: HexAddress|integer
        description: Starting address
      - name: end_addr
        type: HexAddress|integer
        description: Ending address
      - name: user_only
        type: boolean
        description: Only return user tags
    run_transaction:
      description: Run a function within a database transaction
      returns: boolean
      params:
      - name: func
        type: function
        description: Function to execute within the transaction
      example: |
        bv:run_transaction(function()
            bv:set_comment_at_address(addr1, "First")
            bv:set_comment_at_address(addr2, "Second")
        end)
    can_undo:
      description: Check if an undo operation is available
      returns: boolean
    undo:
      description: Undo the last operation
      returns: boolean
      example: |
        if bv:can_undo() then bv:undo() end
    can_redo:
      description: Check if a redo operation is available
      returns: boolean
    redo:
      description: Redo the last undone operation
      returns: boolean
    get_type_by_name:
      description: Get a type definition by name
      returns: Type
      params:
      - name: name
        type: string
        description: Name of the type
      example: |
        local my_struct = bv:get_type_by_name("my_struct")
        if my_struct then
            print("Struct size:", my_struct.width)
        end
    get_type_by_id:
      description: Get a type definition by its unique ID
      returns: Type
      params:
      - name: id
        type: string
        description: Type ID
    get_type_id:
      description: Get the ID of a type by name
      returns: string
      params:
      - name: name
        type: string
        description: Name of the type
    types:
      description: Get all defined types in the binary
      returns: table
      example: |
        for name, t in pairs(bv:types()) do
            if t.is_structure then
                print("Struct:", name, "size:", t.width)
            end
        end
    define_user_type:
      description: Define a new user type
      returns: boolean
      params:
      - name: name
        type: string
        description: Name for the type
      - name: typeStr
        type: string
        description: Type definition string
      example: |
        bv:define_user_type("my_struct", "struct { int x; int y; }")
    undefine_user_type:
      description: Remove a user-defined type
      params:
      - name: name
        type: string
        description: Name of the type to remove
    parse_type_string:
      description: Parse a type string and return the type
      returns: multiple
      params:
      - name: typeStr
        type: string
        description: Type string to parse
      example: |
        local t, name = bv:parse_type_string("int (*)(void)")
        if t then print("Parsed function pointer") end
    get_type_refs_for_type:
      description: Get all references to a type
      returns: table
      params:
      - name: typeName
        type: string
        description: Name of the type
    get_outgoing_type_refs:
      description: Get types referenced by a type
      returns: table
      params:
      - name: typeName
        type: string
        description: Name of the type
    get_outgoing_recursive_type_refs:
      description: Get all types referenced by a type recursively
      returns: table
      params:
      - name: typeName
        type: string
        description: Name of the type
    update_analysis:
      description: Request an analysis update (non-blocking)
      example: |
        bv:update_analysis()  -- Returns immediately
    update_analysis_and_wait:
      description: Request an analysis update and wait for completion
      example: |
        bv:update_analysis_and_wait()  -- Blocks until done
    abort_analysis:
      description: Abort the current analysis
    get_analysis_progress:
      description: Get the current analysis progress
      returns: table
      example: |
        local progress = bv:get_analysis_progress()
        print("Analysis progress:", progress.state)
    store_metadata:
      description: Store metadata in the binary database
      params:
      - name: key
        type: string
        description: Metadata key
      - name: value
        type: any
        description: Metadata value
      - name: isAuto
        type: boolean
        description: Whether this is auto-generated metadata
      example: |
        bv:store_metadata("analyzed_by", "my_script")
    query_metadata:
      description: Retrieve stored metadata
      returns: any
      params:
      - name: key
        type: string
        description: Metadata key to query
      example: |
        local author = bv:query_metadata("analyzed_by")
        if author then print("Analyzed by:", author) end
    remove_metadata:
      description: Remove stored metadata
      params:
      - name: key
        type: string
        description: Metadata key to remove
    show_plain_text_report:
      description: Display a plain text report in the UI
      params:
      - name: title
        type: string
        description: Report title
      - name: contents
        type: string
        description: Report content
      example: |
        bv:show_plain_text_report("Analysis Results", "Found 10 issues")
    show_markdown_report:
      description: Display a markdown-formatted report in the UI
      params:
      - name: title
        type: string
        description: Report title
      - name: contents
        type: string
        description: Markdown content
      - name: plaintext
        type: string
        description: Optional plaintext fallback
      example: |
        bv:show_markdown_report("Report", "# Summary\n- Item 1\n- Item 2")
    show_html_report:
      description: Display an HTML report in the UI
      params:
      - name: title
        type: string
        description: Report title
      - name: contents
        type: string
        description: HTML content
      - name: plaintext
        type: string
        description: Optional plaintext fallback
    show_graph_report:
      description: Display a flow graph report in the UI
      params:
      - name: title
        type: string
        description: Report title
      - name: graph
        type: FlowGraph
        description: Flow graph to display
      example: |
        local graph = func:create_graph()
        bv:show_graph_report("Function Graph", graph)

HexAddress:
  description: |
    Wrapper for memory addresses with hex formatting and arithmetic support. Displays in hexadecimal format. Use .value to get the raw numeric value.
  properties:
    value:
      type: integer
      description: Raw integer value of the address
      example: |
        local addr = bv.start_addr
        local numeric = addr.value
        local next_page = addr.value + 0x1000

Selection:
  description: |
    Represents a selected address range in the UI. Available as current_selection magic variable when the user has selected a range.
  properties:
    start_addr:
      type: HexAddress
      description: Starting address of the selection
      example: |
        if current_selection then
            print("Selection starts at:", current_selection.start_addr)
        end
    end_addr:
      type: HexAddress
      description: Ending address of the selection
      example: |
        local sel = current_selection
        print("Selected range:", sel.start_addr, "to", sel.end_addr)
    length:
      type: integer
      description: Length of the selection in bytes
      example: |
        print("Selected", current_selection.length, "bytes")

Section:
  description: |
    Represents a section in the binary (e.g., .text, .data, .rodata). Sections define regions with specific semantics and permissions.
  properties:
    name:
      type: string
      description: Name of the section
      example: |
        for _, s in ipairs(bv:sections()) do
            print(s.name)
        end
    start_addr:
      type: HexAddress
      description: Starting address of the section
      example: |
        local text = bv:sections()[1]
        print("Section starts at:", text.start_addr)
    length:
      type: integer
      description: Size of the section in bytes
      example: |
        for _, s in ipairs(bv:sections()) do
            print(s.name, s.length, "bytes")
        end
    type:
      type: string
      description: Section type identifier ("code", "data", "external", "default")
      example: |
        for _, s in ipairs(bv:sections()) do
            if s.type == "code" then
                print("Code section:", s.name)
            end
        end
  methods:
    permissions:
      description: Get the section permissions (read, write, execute)
      returns: table
      example: |
        local perms = section:permissions()
        if perms.execute then
            print("Executable section")
        end

Symbol:
  description: |
    Represents a symbol (function name, variable name, import, export) in the binary. Symbols provide human-readable names for addresses.
  properties:
    name:
      type: string
      description: Full name of the symbol (may include namespace/mangling)
      example: |
        local sym = func.symbol
        if sym then print("Full name:", sym.name) end
    short_name:
      type: string
      description: Short name of the symbol (demangled, without namespace)
      example: |
        for _, imp in ipairs(bv:imports()) do
            print(imp.short_name)
        end
    address:
      type: HexAddress
      description: Address of the symbol
      example: |
        for _, exp in ipairs(bv:exports()) do
            print(exp.short_name, "@", exp.address)
        end
    type:
      type: string
      description: Symbol type as string (e.g., "Function", "Data", "ImportedFunction")
      example: |
        for _, sym in ipairs(bv:exports()) do
            print(sym.short_name, "type:", sym.type)
        end
    type_value:
      type: integer
      description: Symbol type as numeric value

DataVariable:
  description: |
    Represents a defined data variable at an address (global variables, constants, etc.).
  properties:
    address:
      type: HexAddress
      description: Address of the data variable
      example: |
        for _, var in ipairs(bv:data_vars()) do
            print(var.address, var.name)
        end
    type:
      type: string
      description: Type of the data variable as a string
      example: |
        local var = bv:get_data_var_at(0x404000)
        if var then print("Type:", var.type) end
    auto_discovered:
      type: boolean
      description: Whether the variable was auto-discovered by analysis
    name:
      type: string
      description: Name of the data variable
    type_confidence:
      type: integer
      description: Confidence level of the type assignment (0-255)

FlowGraphNode:
  description: |
    Represents a node in a flow graph visualization. Each node typically corresponds to a basic block.
  properties:
    x:
      type: integer
      description: X coordinate of the node
      writable: true
    y:
      type: integer
      description: Y coordinate of the node
      writable: true
    width:
      type: integer
      description: Width of the node
    height:
      type: integer
      description: Height of the node
    basic_block:
      type: BasicBlock
      description: The basic block this node represents
      example: |
        for _, node in ipairs(graph:nodes()) do
            local bb = node.basic_block
            if bb then print("Node for block at:", bb.start_addr) end
        end
    highlight:
      type: table
      description: Highlight color settings for the node
      writable: true
  methods:
    lines:
      description: Get the text lines displayed in this node
      returns: table
    set_lines:
      description: Set the text lines for this node
      params:
      - name: lines
        type: table
        description: Array of line objects
    outgoing_edges:
      description: Get all outgoing edges from this node
      returns: table
      example: |
        local edges = node:outgoing_edges()
        print("Node has", #edges, "successors")
    incoming_edges:
      description: Get all incoming edges to this node
      returns: table
    add_outgoing_edge:
      description: Add an outgoing edge to another node
      params:
      - name: type
        type: string
        description: Edge type (e.g., "branch", "fallthrough")

FlowGraph:
  description: |
    Represents a flow graph visualization for functions or IL. Can be displayed in reports or customized programmatically.
  properties:
    width:
      type: integer
      description: Total width of the graph layout
      writable: true
    height:
      type: integer
      description: Total height of the graph layout
      writable: true
    node_count:
      type: integer
      description: Number of nodes in the graph
      example: print("Graph has", graph.node_count, "nodes")
    has_nodes:
      type: boolean
      description: Whether the graph has any nodes
    function:
      type: Function
      description: The function this graph represents
    view:
      type: BinaryView
      description: The binary view containing this graph
    is_il:
      type: boolean
      description: Whether this is an IL graph
    is_llil:
      type: boolean
      description: Whether this is a Low Level IL graph
    is_mlil:
      type: boolean
      description: Whether this is a Medium Level IL graph
    is_hlil:
      type: boolean
      description: Whether this is a High Level IL graph
    is_layout_complete:
      type: boolean
      description: Whether the graph layout has been computed
  methods:
    nodes:
      description: Get all nodes in the graph
      returns: table
      example: |
        for _, node in ipairs(graph:nodes()) do
            print("Node at", node.x, node.y)
        end
    get_node:
      description: Get a node by index
      returns: FlowGraphNode
      params:
      - name: index
        type: integer
        description: Node index
    add_node:
      description: Add a new node to the graph
      returns: integer
    create_node:
      description: Create and add a new node
      returns: FlowGraphNode
      example: |
        local graph = FlowGraph.new()
        local node = graph:create_node()
    clear_nodes:
      description: Remove all nodes from the graph
      returns: any

Function:
  description: |
    Represents a function in the binary with its properties, instructions, and analysis data. The core unit of code analysis.
  properties:
    start_addr:
      type: HexAddress
      description: Starting address of the function
      example: print("Function starts at:", func.start_addr)
      aliases:
      - start
    start:
      type: HexAddress
      description: Alias for start_addr
    end_addr:
      type: HexAddress
      description: Ending address of the function (exclusive)
      aliases:
      - end
    end:
      type: HexAddress
      description: Alias for end_addr
    size:
      type: integer
      description: Size of the function in bytes
      example: print("Function size:", func.size, "bytes")
    name:
      type: string
      description: Name of the function
      example: print("Function:", func.name)
    arch:
      type: string
      description: Architecture of the function
    comment:
      type: string
      description: Comment attached to the function
      example: |
        if func.comment ~= "" then
            print("Comment:", func.comment)
        end
    symbol:
      type: Symbol
      description: Symbol associated with this function
    view:
      type: BinaryView
      description: Binary view containing this function
    auto_discovered:
      type: boolean
      description: Whether the function was auto-discovered by analysis
      aliases:
      - auto
      example: |
        local user_funcs = {}
        for _, f in ipairs(bv:functions()) do
            if not f.auto_discovered then
                table.insert(user_funcs, f)
            end
        end
    has_user_annotations:
      type: boolean
      description: Whether the function has user annotations
    is_pure:
      type: boolean
      description: Whether the function is marked as pure (no side effects)
    has_explicitly_defined_type:
      type: boolean
      description: Whether the function has an explicitly defined type signature
    has_user_type:
      type: boolean
      description: Whether the function has a user-defined type
    has_unresolved_indirect_branches:
      type: boolean
      description: Whether the function has unresolved indirect branches
    analysis_skipped:
      type: boolean
      description: Whether analysis was skipped for this function
    too_large:
      type: boolean
      description: Whether the function is too large for complete analysis
    needs_update:
      type: boolean
      description: Whether the function needs reanalysis
    analysis_skip_reason:
      type: string
      description: Reason why analysis was skipped
    can_return:
      type: boolean
      description: Whether the function can return to its caller
    auto:
      type: boolean
      description: Alias for auto_discovered
    is_exported:
      type: boolean
      description: Whether the function is exported
      example: |
        for _, f in ipairs(bv:functions()) do
            if f.is_exported then
                print("Exported:", f.name)
            end
        end
    is_inlined_during_analysis:
      type: boolean
      description: Whether the function is inlined during analysis
    is_thunk:
      type: boolean
      description: Whether the function is a thunk (simple jump wrapper)
      example: |
        for _, f in ipairs(bv:functions()) do
            if f.is_thunk then
                print("Thunk:", f.name)
            end
        end
    stack_adjustment:
      type: integer|nil
      description: Stack pointer adjustment made by this function
  methods:
    basic_blocks:
      description: Get all basic blocks in the function
      returns: table
      example: |
        local blocks = func:basic_blocks()
        print("Function has", #blocks, "basic blocks")
    calls:
      description: Get all functions called by this function
      returns: table
      example: |
        for _, called in ipairs(func:calls()) do
            print("Calls:", called.name)
        end
      aliases:
      - callees
    callers:
      description: Get all functions that call this function
      returns: table
      example: |
        for _, caller in ipairs(func:callers()) do
            print("Called by:", caller.name)
        end
    call_sites:
      description: Get addresses of call instructions in this function
      returns: table
      example: |
        for _, addr in ipairs(func:call_sites()) do
            print("Call at:", addr)
        end
    callees:
      description: Get all functions called by this function (alias for calls)
      returns: table
    callee_addresses:
      description: Get addresses of all called functions
      returns: table
    caller_sites:
      description: Get addresses where this function is called
      returns: table
    variables:
      description: Get all local variables in the function
      returns: table
      example: |
        for _, var in ipairs(func:variables()) do
            print(var.name, ":", var.type)
        end
    parameter_vars:
      description: Get parameter variables of the function
      returns: table
      example: |
        for i, param in ipairs(func:parameter_vars()) do
            print("Param", i, ":", param.name, param.type)
        end
    clobbered_regs:
      description: Get registers clobbered by this function
      returns: table
      example: |
        print("Clobbered registers:", table.concat(func:clobbered_regs(), ", "))
    get_variable_by_name:
      description: Find a variable by name
      returns: Variable|nil
      params:
      - name: name
        type: string
        description: Variable name to search for
      example: |
        local var = func:get_variable_by_name("counter")
        if var then print("Found:", var.type) end
    create_user_var:
      description: Create a user-defined variable
      returns: boolean
      params:
      - name: storage
        type: integer
        description: Variable storage location
      - name: typeStr
        type: string
        description: Type string for the variable
      - name: name
        type: string
        description: Name for the variable
    delete_user_var:
      description: Delete a user-defined variable
      params:
      - name: var
        type: Variable
        description: Variable to delete
    comment_at_address:
      description: Get the comment at an address within this function
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to query
    set_comment:
      description: Set the function's comment
      returns: boolean
      params:
      - name: comment
        type: string
        description: Comment text
      example: |
        func:set_comment("This function handles authentication")
    set_comment_at_address:
      description: Set a comment at an address within this function
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address for the comment
      - name: comment
        type: string
        description: Comment text
    set_name:
      description: Rename the function
      returns: boolean
      params:
      - name: name
        type: string
        description: New function name
      example: |
        func:set_name("handle_authentication")
    set_return_type:
      description: Set the function's return type
      returns: boolean
      params:
      - name: typeStr
        type: string
        description: Type string for return type
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
      example: |
        func:set_return_type("int", true)
    set_parameter_type:
      description: Set a parameter's type
      returns: boolean
      params:
      - name: index
        type: integer
        description: Parameter index
      - name: typeStr
        type: string
        description: Type string for the parameter
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    set_parameter_name:
      description: Set a parameter's name
      returns: boolean
      params:
      - name: index
        type: integer
        description: Parameter index
      - name: name
        type: string
        description: New parameter name
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
      example: |
        func:set_parameter_name(0, "user_input", true)
    add_parameter:
      description: Add a new parameter to the function
      returns: boolean
      params:
      - name: typeStr
        type: string
        description: Type string for the parameter
      - name: name
        type: string
        description: Optional parameter name
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    remove_parameter:
      description: Remove a parameter from the function
      returns: boolean
      params:
      - name: index
        type: integer
        description: Parameter index to remove
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    set_calling_convention:
      description: Set the function's calling convention
      returns: boolean
      params:
      - name: ccName
        type: string
        description: Calling convention name
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
      example: |
        func:set_calling_convention("fastcall", true)
    set_can_return:
      description: Set whether the function can return
      params:
      - name: canReturn
        type: boolean
        description: Whether the function can return
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    set_has_variable_arguments:
      description: Set whether the function has variable arguments
      params:
      - name: hasVarArgs
        type: boolean
        description: Whether function has variable arguments
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    set_is_pure:
      description: Set whether the function is pure
      params:
      - name: isPure
        type: boolean
        description: Whether the function is pure
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    set_analysis_skipped:
      description: Set whether to skip analysis for this function
      params:
      - name: skip
        type: boolean
        description: Whether to skip analysis
    set_user_inlined:
      description: Set whether the function should be inlined during analysis
      params:
      - name: inlined
        type: boolean
        description: Whether to inline
      - name: reanalyze
        type: boolean
        description: Whether to trigger reanalysis
    reanalyze:
      description: Request reanalysis of this function
      example: |
        func:set_return_type("void*")
        func:reanalyze()
    mark_updates_required:
      description: Mark that this function needs updates
    get_llil:
      description: Get the Low Level IL for this function
      returns: Llil
      example: |
        local llil = func:get_llil()
        print("LLIL instructions:", llil.instruction_count)
    get_mlil:
      description: Get the Medium Level IL for this function
      returns: Mlil
      example: |
        local mlil = func:get_mlil()
        print("MLIL instructions:", mlil.instruction_count)
    get_hlil:
      description: Get the High Level IL for this function
      returns: Hlil
      example: |
        local hlil = func:get_hlil()
        print("HLIL instructions:", hlil.instruction_count)
    type:
      description: Get the function's type signature
      returns: table
      example: |
        local t = func:type()
        print("Return type:", t.return_type)
    disassembly:
      description: Get the disassembly for this function
      returns: table
      example: |
        for _, line in ipairs(func:disassembly()) do
            print(line)
        end
    control_flow_graph:
      description: Get the control flow graph
      returns: table
    stack_layout:
      description: Get the stack layout for this function
      returns: table
      example: |
        for _, entry in ipairs(func:stack_layout()) do
            print(entry.offset, entry.name, entry.type)
        end
    merged_vars:
      description: Get merged variables in this function
      returns: table
    split_vars:
      description: Get split variables in this function
      returns: table
    split_variable:
      description: Split a variable
      params:
      - name: var
        type: Variable
        description: Variable to split
    get_mlil_var_refs:
      description: Get MLIL references to a variable
      returns: table
      params:
      - name: var
        type: Variable
        description: Variable to query
    get_hlil_var_refs:
      description: Get HLIL references to a variable
      returns: table
      params:
      - name: var
        type: Variable
        description: Variable to query
    get_tags:
      description: Get all tags on this function
      returns: table
      example: |
        for _, tag in ipairs(func:get_tags()) do
            print(tag.type.icon, tag.data)
        end
    get_tags_at:
      description: Get tags at an address within this function
      returns: table
      params:
      - name: addr
        type: integer
        description: Address to query
    add_tag:
      description: Add a tag to this function
      params:
      - name: addr
        type: integer
        description: Address for the tag
      - name: tag
        type: Tag
        description: Tag to add
      - name: user
        type: boolean
        description: Whether this is a user tag
    remove_tag:
      description: Remove a tag from this function
      params:
      - name: addr
        type: integer
        description: Address of the tag
      - name: tag
        type: Tag
        description: Tag to remove
      - name: user
        type: boolean
        description: Whether this is a user tag
    create_user_tag:
      description: Create and add a user tag
      returns: Tag
      params:
      - name: addr
        type: integer
        description: Address for the tag
      - name: tagTypeName
        type: string
        description: Tag type name
      - name: data
        type: string
        description: Tag data
      example: |
        func:create_user_tag(func.start_addr.value, "Bug", "Needs review")
    store_metadata:
      description: Store metadata on this function
      params:
      - name: key
        type: string
        description: Metadata key
      - name: value
        type: any
        description: Metadata value
      - name: isAuto
        type: boolean
        description: Whether auto-generated
    query_metadata:
      description: Query metadata on this function
      returns: any
      params:
      - name: key
        type: string
        description: Metadata key
    remove_metadata:
      description: Remove metadata from this function
      params:
      - name: key
        type: string
        description: Metadata key to remove
    create_graph:
      description: Create a flow graph for this function
      returns: FlowGraph
      params:
      - name: type
        type: string
        description: Graph type (e.g., "normal", "llil", "mlil", "hlil")
      example: |
        local graph = func:create_graph("hlil")
        bv:show_graph_report("HLIL Graph", graph)
    create_graph_immediate:
      description: Create a flow graph immediately (blocking)
      returns: FlowGraph
      params:
      - name: type
        type: string
        description: Graph type

Llil:
  description: |
    Low Level Intermediate Language representation of a function. Closest to assembly, maintains register and flag operations.
  properties:
    instruction_count:
      type: integer
      description: Number of LLIL instructions
      example: print("LLIL instructions:", llil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the LLIL
  methods:
    get_function:
      description: Get the parent function
      returns: Function
      example: |
        local llil = func:get_llil()
        print("LLIL for:", llil:get_function().name)
    instruction_at:
      description: Get the LLIL instruction at an index
      returns: any
      params:
      - name: index
        type: integer
        description: Instruction index
      example: |
        for i = 0, llil.instruction_count - 1 do
            local instr = llil:instruction_at(i)
            print(i, llil:get_text(i))
        end
    get_text:
      description: Get text representation of an instruction
      returns: string
      params:
      - name: index
        type: integer
        description: Instruction index
    create_graph:
      description: Create a flow graph for the LLIL
      returns: FlowGraph
      example: |
        local graph = llil:create_graph()
        bv:show_graph_report("LLIL Graph", graph)
    create_graph_immediate:
      description: Create a flow graph immediately
      returns: FlowGraph

Mlil:
  description: |
    Medium Level Intermediate Language representation. Abstracts away registers into variables, simplifies stack operations.
  properties:
    instruction_count:
      type: integer
      description: Number of MLIL instructions
      example: print("MLIL instructions:", mlil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the MLIL
  methods:
    get_function:
      description: Get the parent function
      returns: Function
    instruction_at:
      description: Get the MLIL instruction at an index
      returns: any
      params:
      - name: index
        type: integer
        description: Instruction index
    get_text:
      description: Get text representation of an instruction
      returns: string
      params:
      - name: index
        type: integer
        description: Instruction index
    create_graph:
      description: Create a flow graph for the MLIL
      returns: FlowGraph
    create_graph_immediate:
      description: Create a flow graph immediately
      returns: FlowGraph

Hlil:
  description: |
    High Level Intermediate Language representation. Closest to source code with structured control flow and expressions.
  properties:
    instruction_count:
      type: integer
      description: Number of HLIL instructions
      example: print("HLIL instructions:", hlil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the HLIL
  methods:
    get_function:
      description: Get the parent function
      returns: Function
    instruction_at:
      description: Get the HLIL instruction at an index
      returns: any
      params:
      - name: index
        type: integer
        description: Instruction index
    get_text:
      description: Get text representation of an instruction
      returns: string
      params:
      - name: index
        type: integer
        description: Instruction index
      example: |
        local hlil = func:get_hlil()
        for i = 0, hlil.instruction_count - 1 do
            print(hlil:get_text(i))
        end
    create_graph:
      description: Create a flow graph for the HLIL
      returns: FlowGraph
    create_graph_immediate:
      description: Create a flow graph immediately
      returns: FlowGraph

Instruction:
  description: |
    Represents a single disassembled instruction with its mnemonic, operands, and raw bytes.
  properties:
    address:
      type: HexAddress
      description: Address of the instruction
      example: print("Instruction at:", instr.address)
    mnemonic:
      type: string
      description: Instruction mnemonic (e.g., "mov", "push", "call")
      example: |
        if instr.mnemonic == "call" then
            print("Call instruction at", instr.address)
        end
    length:
      type: integer
      description: Length of the instruction in bytes
    text:
      type: string
      description: Full text representation of the instruction
      example: print(instr.text)  -- e.g., "mov eax, [rbp-0x8]"
    arch:
      type: string
      description: Architecture of the instruction
  methods:
    operands:
      description: Get the instruction operands as strings
      returns: table
      example: |
        local ops = instr:operands()
        for i, op in ipairs(ops) do
            print("Operand", i, ":", op)
        end
    bytes:
      description: Get the raw bytes of the instruction
      returns: string
      example: |
        local b = instr:bytes()
        print("Bytes:", b:gsub(".", function(c)
            return string.format("%02X ", c:byte())
        end))
    references:
      description: Get addresses referenced by this instruction
      returns: table
      example: |
        for _, ref in ipairs(instr:references()) do
            print("References:", ref)
        end

TagType:
  description: |
    Defines a type of tag that can be applied to addresses or functions. Tag types have icons and names for categorization.
  properties:
    id:
      type: string
      description: Unique identifier for the tag type
    name:
      type: string
      description: Display name of the tag type
      example: |
        for _, tt in ipairs(bv:tag_types()) do
            print(tt.name)
        end
    icon:
      type: string
      description: Icon emoji for the tag type
      example: |
        local bug_type = bv:create_tag_type("Bug", "!")
        print(bug_type.icon)  -- "!"
    visible:
      type: boolean
      description: Whether tags of this type are visible in the UI
    type:
      type: string
      description: Type category string
  methods:
    set_name:
      description: Change the tag type name
      params:
      - name: name
        type: string
        description: New name
    set_icon:
      description: Change the tag type icon
      params:
      - name: icon
        type: string
        description: New icon emoji
    set_visible:
      description: Set tag type visibility
      params:
      - name: visible
        type: boolean
        description: Whether to show tags of this type

Tag:
  description: |
    A tag instance applied to an address or function. Tags provide annotations with categorization via TagType.
  properties:
    id:
      type: string
      description: Unique identifier for this tag
    type:
      type: TagType
      description: The tag type of this tag
      example: |
        local tag = func:get_tags()[1]
        print("Tag type:", tag.type.name)
    data:
      type: string
      description: Data/content stored in this tag
      example: |
        for _, tag in ipairs(func:get_tags()) do
            print(tag.type.icon, tag.data)
        end
  methods:
    set_data:
      description: Change the tag's data content
      params:
      - name: data
        type: string
        description: New data content
      example: |
        tag:set_data("Updated description")

Type:
  description: |
    Represents a type definition (struct, enum, pointer, function type, etc.). Used for type analysis and variable typing.
  properties:
    type_class:
      type: string
      description: Type class as string (e.g., "structure", "pointer", "integer")
      example: |
        local t = bv:get_type_by_name("my_struct")
        print("Type class:", t.type_class)  -- "structure"
    type_class_value:
      type: integer
      description: Type class as numeric value
    width:
      type: integer
      description: Size of the type in bytes
      example: |
        local t = bv:get_type_by_name("my_struct")
        print("Size:", t.width, "bytes")
    alignment:
      type: integer
      description: Alignment requirement in bytes
    name:
      type: string
      description: Name of the type (if named)
    is_void:
      type: boolean
      description: Whether this is the void type
    is_bool:
      type: boolean
      description: Whether this is a boolean type
    is_integer:
      type: boolean
      description: Whether this is an integer type
    is_float:
      type: boolean
      description: Whether this is a floating-point type
    is_structure:
      type: boolean
      description: Whether this is a structure type
      example: |
        for name, t in pairs(bv:types()) do
            if t.is_structure then
                print("Struct:", name)
            end
        end
    is_enumeration:
      type: boolean
      description: Whether this is an enumeration type
    is_pointer:
      type: boolean
      description: Whether this is a pointer type
    is_array:
      type: boolean
      description: Whether this is an array type
    is_function:
      type: boolean
      description: Whether this is a function type
    is_signed:
      type: boolean
      description: Whether this is a signed integer type
    is_const:
      type: boolean
      description: Whether this type has const qualifier
    is_volatile:
      type: boolean
      description: Whether this type has volatile qualifier
    element_count:
      type: integer
      description: Number of elements (for arrays)
    return_type:
      type: string
      description: Return type (for function types)
    has_variable_arguments:
      type: boolean
      description: Whether function type has variable arguments
    can_return:
      type: boolean
      description: Whether function type can return
  methods:
    target:
      description: Get the target type (for pointers/arrays)
      returns: Type
      example: |
        if t.is_pointer then
            local target = t:target()
            print("Points to:", target:get_string())
        end
    members:
      description: Get structure members
      returns: any
      example: |
        if t.is_structure then
            for _, m in ipairs(t:members()) do
                print(m.offset, m.name, m.type)
            end
        end
    get_member_by_name:
      description: Get a structure member by name
      returns: any
      params:
      - name: name
        type: string
        description: Member name
      example: |
        local member = t:get_member_by_name("count")
        if member then print("Offset:", member.offset) end
    get_member_at_offset:
      description: Get the structure member at an offset
      returns: any
      params:
      - name: offset
        type: integer
        description: Byte offset
      example: |
        local member = t:get_member_at_offset(8)
        if member then print("Member at 8:", member.name) end
    enum_members:
      description: Get enumeration members
      returns: any
      example: |
        if t.is_enumeration then
            for _, m in ipairs(t:enum_members()) do
                print(m.name, "=", m.value)
            end
        end
    parameters:
      description: Get function parameters
      returns: any
      example: |
        if t.is_function then
            for i, p in ipairs(t:parameters()) do
                print("Param", i, ":", p.name, p.type)
            end
        end
    get_string:
      description: Get the type as a string representation
      returns: string
      example: |
        print("Type:", t:get_string())  -- e.g., "int (*)(void*, size_t)"

Variable:
  description: |
    Represents a local variable or parameter in a function. Variables have names, types, and storage locations.
  properties:
    name:
      type: string
      description: Name of the variable
      example: |
        for _, v in ipairs(func:variables()) do
            print(v.name)
        end
    type:
      type: string
      description: Type of the variable as a string
      example: |
        for _, v in ipairs(func:variables()) do
            print(v.name, ":", v.type)
        end
    type_name:
      type: string
      description: Type name without qualifiers
    index:
      type: integer
      description: Variable index
    source_type:
      type: string
      description: Variable source ("stack", "register", "flag")
      example: |
        for _, v in ipairs(func:variables()) do
            if v.source_type == "stack" then
                print("Stack var:", v.name)
            end
        end
  methods:
    location:
      description: Get the storage location of the variable
      returns: table
      example: |
        local loc = var:location()
        print("Storage:", loc.type, loc.offset or loc.register)
    set_name:
      description: Rename the variable
      returns: boolean
      params:
      - name: name
        type: string
        description: New variable name
      example: |
        var:set_name("buffer_ptr")
    set_type:
      description: Change the variable's type
      returns: boolean
      params:
      - name: typeStr
        type: string
        description: New type string
      example: |
        var:set_type("char*")
