# Auto-extracted API definitions from C++ bindings
# Generated by docs/extract_api.py
# TODO items need manual documentation

HexAddress:
  description: |
    Wrapper type for addresses that displays in hexadecimal format. Supports arithmetic operations and comparisons. Use .value to get the raw numeric value for calculations.
  properties:
    value:
      type: integer
      description: Raw numeric value of the address for arithmetic operations
      example: |
        local addr = bv.start_addr
        local numeric = addr.value  -- Get as number
        local next_page = addr.value + 0x1000
Selection:
  description: |
    Represents a selected address range in the Binary Ninja UI. Available as current_selection magic variable when the user has selected a range.
  properties:
    start_addr:
      type: HexAddress
      description: Start address of the selected range
      example: |
        if current_selection then
            print("Selection starts at:", current_selection.start_addr)
        end
    end_addr:
      type: HexAddress
      description: End address of the selected range (exclusive)
      example: |
        local sel = current_selection
        print("Selected range:", sel.start_addr, "to", sel.end_addr)
    length:
      type: integer
      description: Length of the selection in bytes
      example: |
        print("Selected", current_selection.length, "bytes")
Section:
  description: |
    Represents a section in the binary (e.g., .text, .data, .rodata). Sections define regions of the binary with specific semantics and permissions.
  properties:
    name:
      type: string
      description: Name of the section (e.g., ".text", ".data", ".rodata")
      example: |
        for _, s in ipairs(bv:sections()) do
            print(s.name)
        end
    start_addr:
      type: HexAddress
      description: Starting address of the section
      example: |
        local text = bv:sections()[1]
        print("Section starts at:", text.start_addr)
    length:
      type: integer
      description: Size of the section in bytes
      example: |
        for _, s in ipairs(bv:sections()) do
            print(s.name, s.length, "bytes")
        end
    type:
      type: string
      description: Section type - "code", "data", "external", or "default"
      example: |
        for _, s in ipairs(bv:sections()) do
            if s.type == "code" then
                print("Code section:", s.name)
            end
        end
  methods:
    permissions:
      description: Get the section's memory permissions
      returns: 'table<{read: boolean, write: boolean, execute: boolean}>'
      example: |
        local perms = section:permissions()
        if perms.execute then
            print("Executable section")
        end
Symbol:
  description: |
    Represents a symbol (function name, variable name, import, export, etc.) in the binary. Symbols provide human-readable names for addresses.
  properties:
    name:
      type: string
      description: Full name of the symbol (may include namespace/mangling)
      example: |
        local sym = func.symbol
        if sym then print("Full name:", sym.name) end
    short_name:
      type: string
      description: Demangled/shortened name suitable for display
      example: |
        for _, imp in ipairs(bv:imports()) do
            print(imp.short_name)
        end
    address:
      type: HexAddress
      description: Address where the symbol is located
      example: |
        for _, exp in ipairs(bv:exports()) do
            print(exp.short_name, "@", exp.address)
        end
    type:
      type: string
      description: |
        Symbol type string - "Function", "ImportAddress", "ImportedFunction", "Data", "ImportedData", "External", "LibraryFunction", "LocalLabel", etc.
      example: |
        for _, sym in ipairs(bv:exports()) do
            print(sym.short_name, "type:", sym.type)
        end
    type_value:
      type: integer
      description: Numeric symbol type value for programmatic comparisons
      example: |
        -- Use type string instead for readability
        if sym.type == "Function" then ... end
BinaryView:
  description: |
    Main interface for analyzing loaded binary files. Provides access to functions, memory, sections, symbols, and metadata. Available as the 'bv' magic variable.
  properties:
    start_addr:
      type: HexAddress
      description: Starting address of the binary view's address space
      example: print(bv.start_addr)  -- e.g., 0x140000000
      aliases:
      - start
    start:
      type: HexAddress
      description: Alias for start_addr
    end_addr:
      type: HexAddress
      description: End address of the binary view (one past the last valid address)
      example: print(bv.end_addr)
      aliases:
      - end
    end:
      type: HexAddress
      description: 'Alias for end_addr (note: use bv["end"] since ''end'' is a Lua keyword)'
    length:
      type: integer
      description: Total size of the binary in bytes
      example: print('Size:', bv.length, 'bytes')
    file:
      type: string
      description: Full path to the loaded binary file
      example: print('File:', bv.file)
      aliases:
      - filename
    filename:
      type: string
      description: Alias for file property
    arch:
      type: string
      description: Architecture name (e.g., 'x86_64', 'x86', 'armv7', 'aarch64', 'thumb2')
      example: print('Architecture:', bv.arch)
    entry_point:
      type: HexAddress
      description: Entry point address of the binary (program start)
      example: |
        local entry_func = bv:get_function_at(bv.entry_point)
        if entry_func then print("Entry:", entry_func.name) end
    has_data_vars:
      type: boolean
      description: Whether the binary has any defined data variables
      example: |
        if bv.has_data_vars then
            print("Data variables:", #bv:data_vars())
        end
  methods:
    functions:
      description: Get all analyzed functions in the binary
      returns: table<Function>
      example: |
        local funcs = bv:functions()
        print('Found', #funcs, 'functions')
        for i = 1, math.min(5, #funcs) do
            print(funcs[i].name)
        end
    sections:
      description: Get all sections in the binary
      returns: table<Section>
      example: |
        for _, section in ipairs(bv:sections()) do
            print(section.name, section.start_addr, section.length)
        end
    strings:
      description: Get all strings found in the binary
      returns: 'table<{addr: HexAddress, length: integer, type: integer, value: string}>'
      example: |
        for _, s in ipairs(bv:strings()) do
            if #s.value > 5 then  -- Skip short strings
                print(s.addr, s.value)
            end
        end
    imports:
      description: Get all imported symbols (functions and data from external libraries)
      returns: table<Symbol>
      example: |
        print("Imports:")
        for _, imp in ipairs(bv:imports()) do
            print(" ", imp.short_name, "@", imp.address)
        end
    exports:
      description: Get all exported symbols (functions and data exposed by this binary)
      returns: table<Symbol>
      example: |
        print("Exports:")
        for _, exp in ipairs(bv:exports()) do
            print(" ", exp.short_name, "@", exp.address)
        end
    data_vars:
      description: Get all defined data variables (global variables, constants)
      returns: table<DataVariable>
      example: |
        for _, var in ipairs(bv:data_vars()) do
            print(var.address, var.name or "<unnamed>", var.type)
        end
    get_function_at:
      description: Get the function that starts at the exact given address
      returns: Function|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Exact start address of the function
      example: |
        local func = bv:get_function_at(0x401000)
        if func then
            print("Found:", func.name)
        else
            print("No function starts at this address")
        end
    get_data_var_at:
      description: Get the data variable defined at the given address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Address to look up
      example: |
        local var = bv:get_data_var_at(0x404000)
        if var then print(var.type) end
    define_data_var:
      description: Define a data variable at the given address (auto-discovered)
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address to define the variable at
      - name: type_str
        type: string
        description: Type string (e.g., 'int32_t', 'char*', 'void*')
      - name: name
        type: string
        description: (optional) Symbol name for the variable
      example: |
        bv:define_data_var(0x404000, "int32_t", "g_counter")
    define_user_data_var:
      description: Define a user data variable and return it (persists in analysis database)
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Address to define the variable at
      - name: type_str
        type: string
        description: Type string
      - name: name
        type: string
        description: (optional) Symbol name for the variable
      example: |
        local var = bv:define_user_data_var(0x404000, "uint64_t", "counter")
        if var then print("Created:", var.name) end
    undefine_data_var:
      description: Remove an auto-discovered data variable definition
      params:
      - name: addr
        type: integer
        description: Address of the variable to undefine
    undefine_user_data_var:
      description: Remove a user-defined data variable definition
      params:
      - name: addr
        type: integer
        description: Address of the variable to undefine
    get_next_data_var_after:
      description: Get the next data variable after the given address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Starting address to search from
      example: |
        local var = bv:get_next_data_var_after(here.value)
        if var then print("Next var at:", var.address) end
    get_previous_data_var_before:
      description: Get the previous data variable before the given address
      returns: DataVariable|nil
      params:
      - name: addr
        type: integer
        description: Starting address to search from
    get_next_function_start_after:
      description: Navigate to the next function after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
      example: |
        local next_func = bv:get_next_function_start_after(here)
        if next_func then print("Next function at:", next_func) end
    get_previous_function_start_before:
      description: Navigate to the previous function before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_next_basic_block_start_after:
      description: Navigate to the next basic block after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_previous_basic_block_start_before:
      description: Navigate to the previous basic block before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_next_data_after:
      description: Navigate to the next defined data item after the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_previous_data_before:
      description: Navigate to the previous defined data item before the given address
      returns: HexAddress|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Starting address
    get_functions_at:
      description: Get all functions starting at the given address (handles overlapping functions)
      returns: table<Function>
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to look up
      example: |
        -- Some addresses may have multiple functions (e.g., different architectures)
        local funcs = bv:get_functions_at(here)
        for _, f in ipairs(funcs) do print(f.name, f.arch) end
    get_functions_containing:
      description: Get all functions whose address range contains the given address
      returns: table<Function>
      params:
      - name: addr
        type: HexAddress|integer
        description: Address that must be within the function
      example: |
        local funcs = bv:get_functions_containing(here)
        for _, f in ipairs(funcs) do
            print("Address is in:", f.name)
        end
    get_basic_blocks_starting_at:
      description: Get all basic blocks that start at the given address
      returns: table<BasicBlock>
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to look up
    get_functions_by_name:
      description: Search for functions by name (exact or substring match)
      returns: table<Function>
      params:
      - name: name
        type: string
        description: Function name or substring to search for
      - name: exact
        type: boolean
        description: (optional, default true) If true, match exact name; if false, substring match
      example: |
        -- Find main function
        local mains = bv:get_functions_by_name("main", true)

        -- Find all sub_ functions
        local subs = bv:get_functions_by_name("sub_", false)
        print("Found", #subs, "unnamed functions")
    find_next_data:
      description: Search for a byte pattern starting from the given address
      returns: HexAddress|nil
      params:
      - name: start
        type: HexAddress|integer
        description: Address to start searching from
      - name: data
        type: string
        description: Byte pattern to search for (Lua string with raw bytes)
      example: |
        -- Search for NOP sled
        local found = bv:find_next_data(bv.start_addr, "\x90\x90\x90\x90")
        if found then print("NOP sled at:", found) end

        -- Search for magic bytes
        local mz = bv:find_next_data(bv.start_addr, "MZ")
    find_all_data:
      description: Find all occurrences of a byte pattern in the given range
      returns: table<HexAddress>
      params:
      - name: start
        type: HexAddress|integer
        description: Start address of search range
      - name: end_addr
        type: HexAddress|integer
        description: End address of search range
      - name: data
        type: string
        description: Byte pattern to search for
      example: |
        -- Find all null dwords in first 0x10000 bytes
        local nulls = bv:find_all_data(bv.start_addr, bv.start_addr.value + 0x10000, "\x00\x00\x00\x00")
        print("Found", #nulls, "null dwords")
    find_next_text:
      description: Search for a text string in the binary data
      returns: HexAddress|nil
      params:
      - name: start
        type: HexAddress|integer
        description: Address to start searching from
      - name: pattern
        type: string
        description: Text string to search for
      example: |
        local pwd = bv:find_next_text(bv.start_addr, "password")
        if pwd then print("Found 'password' at:", pwd) end
    find_all_text:
      description: Find all occurrences of a text string in the given range
      returns: 'table<{addr: HexAddress, match: string}>'
      params:
      - name: start
        type: HexAddress|integer
        description: Start address of search range
      - name: end_addr
        type: HexAddress|integer
        description: End address of search range
      - name: pattern
        type: string
        description: Text string to search for
      example: |
        local results = bv:find_all_text(bv.start_addr, bv.end_addr, "error")
        for _, r in ipairs(results) do
            print(r.addr, r.match)
        end
    find_next_constant:
      description: Search for a constant value used in disassembly instructions
      returns: HexAddress|nil
      params:
      - name: start
        type: HexAddress|integer
        description: Address to start searching from
      - name: constant
        type: integer
        description: Constant value to search for (e.g., immediate operand)
      example: |
        -- Find instructions using magic constant
        local found = bv:find_next_constant(bv.start_addr, 0xDEADBEEF)
        if found then print("Magic constant used at:", found) end
    read:
      description: Read raw bytes from the binary at the given address
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to read from
      - name: len
        type: integer
        description: Number of bytes to read
      example: |
        -- Read and hexdump 16 bytes
        local data = bv:read(bv.entry_point.value, 16)
        local hex = ""
        for i = 1, #data do
            hex = hex .. string.format("%02x ", data:byte(i))
        end
        print(hex)
    get_code_refs:
      description: Get all code references TO the given address (who calls/jumps here?)
      returns: 'table<{addr: HexAddress, func: Function|nil}>'
      params:
      - name: addr
        type: integer
        description: Target address to find references to
      example: |
        local refs = bv:get_code_refs(func.start.value)
        print("Function is called from", #refs, "locations:")
        for _, ref in ipairs(refs) do
            print("  ", ref.addr, ref.func and ref.func.name or "")
        end
    get_data_refs:
      description: Get all data references TO the given address (who reads/writes here?)
      returns: table<HexAddress>
      params:
      - name: addr
        type: integer
        description: Target address to find references to
      example: |
        local refs = bv:get_data_refs(0x404000)
        print("Data is accessed from:")
        for _, addr in ipairs(refs) do print("  ", addr) end
    get_code_refs_from:
      description: Get all code references FROM the given address (what does this call/jump to?)
      returns: table<HexAddress>
      params:
      - name: addr
        type: integer
        description: Source address to find outgoing references from
      example: |
        local targets = bv:get_code_refs_from(here.value)
        for _, target in ipairs(targets) do
            print("References:", target)
        end
    get_data_refs_from:
      description: Get all data references FROM the given address (what data does this access?)
      returns: table<HexAddress>
      params:
      - name: addr
        type: integer
        description: Source address to find outgoing references from
    get_callers:
      description: Get all call sites that call the function at the given address
      returns: 'table<{address: HexAddress, func: Function|nil, arch: string|nil}>'
      params:
      - name: addr
        type: integer
        description: Function address to find callers of
      example: |
        local callers = bv:get_callers(func.start.value)
        print("Called from", #callers, "locations:")
        for _, caller in ipairs(callers) do
            print("  ", caller.address, caller.func and caller.func.name or "")
        end
    get_callees:
      description: Get all addresses that are called from the given address
      returns: table<HexAddress>
      params:
      - name: addr
        type: integer
        description: Address (within a function) to find outgoing calls from
    comment_at_address:
      description: Get the comment at the given address
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to get comment for
      example: |
        local comment = bv:comment_at_address(here.value)
        if comment ~= "" then print("Comment:", comment) end
    set_comment_at_address:
      description: Set or update a comment at the given address
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address to set comment at
      - name: comment
        type: string
        description: Comment text (empty string removes the comment)
      example: |
        bv:set_comment_at_address(here.value, "Interesting code here")
    tag_types:
      description: Get all tag types defined in this binary view
      returns: table<TagType>
      example: |
        for _, tt in ipairs(bv:tag_types()) do
            print(tt.name, tt.icon)
        end
    get_tag_type:
      description: Get a tag type by its name
      returns: TagType|nil
      params:
      - name: name
        type: string
        description: Name of the tag type to look up
    create_tag_type:
      description: Create a new tag type for annotating the binary
      returns: TagType
      params:
      - name: name
        type: string
        description: Name for the tag type
      - name: icon
        type: string
        description: Icon/emoji for the tag type (single character)
      example: |
        local vuln = bv:create_tag_type("Vulnerability", "!")
        local note = bv:create_tag_type("Note", "*")
    remove_tag_type:
      description: Remove a tag type (and all tags of that type)
      params:
      - name: tagType
        type: TagType
        description: Tag type to remove
    get_tags_at:
      description: Get all tags at the given address
      returns: table<Tag>
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to get tags at
      example: |
        local tags = bv:get_tags_at(here)
        for _, tag in ipairs(tags) do
            print(tag.type.name, tag.data)
        end
    add_tag:
      description: Add an existing tag to an address
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to add tag at
      - name: tag
        type: Tag
        description: Tag object to add
      - name: user
        type: boolean
        description: (optional, default true) Whether this is a user-defined tag
    remove_tag:
      description: Remove a tag from an address
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to remove tag from
      - name: tag
        type: Tag
        description: Tag object to remove
      - name: user
        type: boolean
        description: (optional, default true) Whether this is a user-defined tag
    create_user_tag:
      description: Create and add a new tag at an address in one step
      returns: Tag|nil
      params:
      - name: addr
        type: HexAddress|integer
        description: Address to create tag at
      - name: tagTypeName
        type: string
        description: Name of the tag type (must already exist)
      - name: data
        type: string
        description: Tag data/description
      example: |
        bv:create_user_tag(here, "Vulnerability", "Buffer overflow in memcpy")
    get_all_tags:
      description: Get all tags in the entire binary view
      returns: 'table<{addr: HexAddress, tag: Tag, auto: boolean, func: Function|nil}>'
      example: |
        local all_tags = bv:get_all_tags()
        print("Total tags:", #all_tags)
    get_tags_of_type:
      description: Get all tags of a specific type
      returns: 'table<{addr: HexAddress, tag: Tag, auto: boolean, func: Function|nil}>'
      params:
      - name: tagType
        type: TagType
        description: Tag type to filter by
    get_tags_in_range:
      description: Get all tags within a specified address range
      returns: 'table<{addr: HexAddress, tag: Tag, auto: boolean}>'
      params:
      - name: start_addr
        type: HexAddress|integer
        description: Start address of the range to search
      - name: end_addr
        type: HexAddress|integer
        description: End address of the range (exclusive)
      - name: user_only
        type: boolean
        description: (optional, default false) If true, only return user-defined tags
      example: |
        local tags = bv:get_tags_in_range(func.start, func["end"])
        for _, entry in ipairs(tags) do
            print(entry.addr, entry.tag.type.name, entry.tag.data)
        end
    run_transaction:
      description: Run multiple operations as a single undoable transaction
      returns: boolean
      params:
      - name: func
        type: function
        description: Function to run; should return true on success, false to abort
      example: |
        local success = bv:run_transaction(function()
            bv:set_comment_at_address(0x401000, "Modified")
            bv:set_comment_at_address(0x401010, "Also modified")
            return true  -- Commit the transaction
        end)
    can_undo:
      description: Check if undo is available
      returns: boolean
      example: |
        if bv:can_undo() then print("Can undo") end
    undo:
      description: Undo the last action
      returns: boolean
    can_redo:
      description: Check if redo is available
      returns: boolean
    redo:
      description: Redo the last undone action
      returns: boolean
    get_type_by_name:
      description: Look up a type by its name
      returns: Type|nil
      params:
      - name: name
        type: string
        description: Type name to look up (e.g., "HANDLE", "size_t")
      example: |
        local t = bv:get_type_by_name("HANDLE")
        if t then print("Found type:", t) end
    get_type_by_id:
      description: Look up a type by its internal ID
      returns: Type|nil
      params:
      - name: id
        type: string
        description: Internal type ID
    get_type_id:
      description: Get the internal ID for a type name
      returns: string
      params:
      - name: name
        type: string
        description: Type name
    types:
      description: Get all types defined in the binary
      returns: 'table<{name: string, type: Type}>'
      example: |
        for _, entry in ipairs(bv:types()) do
            print(entry.name)
        end
    define_user_type:
      description: Define a new user type from a C-style type string
      returns: boolean
      params:
      - name: name
        type: string
        description: Name for the new type
      - name: type_str
        type: string
        description: C-style type definition
      example: |
        bv:define_user_type("Point", "struct { int x; int y; }")
        bv:define_user_type("Callback", "void (*)(int, void*)")
    undefine_user_type:
      description: Remove a user-defined type
      params:
      - name: name
        type: string
        description: Name of the type to remove
    parse_type_string:
      description: Parse a C-style type string without defining it
      returns: Type|nil, string
      params:
      - name: type_str
        type: string
        description: C-style type string to parse
      example: |
        local t, err = bv:parse_type_string("int (*)(void*, size_t)")
        if t then
            print("Parsed successfully")
        else
            print("Error:", err)
        end
    get_type_refs_for_type:
      description: Find all references to a named type
      returns: 'table<{name: string, offset: integer, ref_type: string}>'
      params:
      - name: typeName
        type: string
        description: Name of the type to find references for
    get_outgoing_type_refs:
      description: Get types directly referenced by the given type
      returns: table<string>
      params:
      - name: typeName
        type: string
        description: Name of the type to analyze
    get_outgoing_recursive_type_refs:
      description: Get all types referenced by the given type (recursively follows nested types)
      returns: table<string>
      params:
      - name: typeName
        type: string
        description: Name of the type to analyze
    get_analysis_progress:
      description: Get current analysis progress information including state, count, and total items
      returns: 'table<{state: string, count: integer, total: integer}>'
      example: |
        local progress = bv:get_analysis_progress()
        print("State:", progress.state)  -- "idle", "initial", "hold", "discovery", etc.
        if progress.state ~= "idle" then
            print(string.format("Progress: %d/%d", progress.count, progress.total))
        end
    update_analysis:
      description: Trigger a background re-analysis of the binary. Returns immediately while analysis runs.
      example: |
        func:set_return_type("int")
        bv:update_analysis()  -- Queue re-analysis
    update_analysis_and_wait:
      description: Trigger re-analysis and wait for it to complete before returning
      example: |
        bv:define_user_type("MyStruct", "struct { int x; int y; }")
        bv:update_analysis_and_wait()
        print("Analysis complete!")
    abort_analysis:
      description: Cancel any currently running analysis
      example: |
        if bv.analysis_progress.state == "running" then
            bv:abort_analysis()
        end
    store_metadata:
      description: Store a value in the binary's metadata database. Supports booleans, strings, integers, doubles, and tables.
      params:
      - name: key
        type: string
        description: Unique key to store the value under
      - name: value
        type: any
        description: Value to store (boolean, string, integer, number, or table)
      - name: isAuto
        type: boolean
        description: (optional, default false) If true, mark as auto-generated (not user-defined)
      example: |
        bv:store_metadata("my_script.last_run", os.time())
        bv:store_metadata("my_script.config", {enabled = true, threshold = 100})
    query_metadata:
      description: Retrieve a previously stored metadata value
      returns: any|nil
      params:
      - name: key
        type: string
        description: Key to look up
      example: |
        local last_run = bv:query_metadata("my_script.last_run")
        if last_run then print("Last run:", last_run) end
    remove_metadata:
      description: Remove a metadata key and its value from the database
      params:
      - name: key
        type: string
        description: Key to remove
      example: |
        bv:remove_metadata("my_script.temp_data")
    show_plain_text_report:
      description: Display a plain text report in Binary Ninja's report panel
      params:
      - name: title
        type: string
        description: Title for the report window
      - name: contents
        type: string
        description: Plain text content to display
      example: |
        local report = "Analysis Report\n===============\n"
        report = report .. "Functions: " .. bv.function_count .. "\n"
        bv:show_plain_text_report("My Analysis", report)
    show_markdown_report:
      description: Display a markdown-formatted report in Binary Ninja's report panel
      params:
      - name: title
        type: string
        description: Title for the report window
      - name: contents
        type: string
        description: Markdown content to display
      - name: plaintext
        type: string
        description: (optional) Plain text fallback for copying
      example: |
        local md = "# Analysis Report\n\n"
        md = md .. "**Functions:** " .. bv.function_count .. "\n"
        md = md .. "| Address | Name |\n|---------|------|\n"
        bv:show_markdown_report("My Analysis", md)
    show_html_report:
      description: Display an HTML report in Binary Ninja's report panel
      params:
      - name: title
        type: string
        description: Title for the report window
      - name: contents
        type: string
        description: HTML content to display
      - name: plaintext
        type: string
        description: (optional) Plain text fallback for copying
      example: |
        local html = "<h1>Report</h1><p>Functions: " .. bv.function_count .. "</p>"
        bv:show_html_report("My Analysis", html)
    show_graph_report:
      description: Display a FlowGraph in Binary Ninja's graph view
      params:
      - name: title
        type: string
        description: Title for the graph window
      - name: graph
        type: FlowGraph
        description: FlowGraph object to display
      example: |
        local func = bv:get_function_at(bv.entry_point)
        if func then
            local graph = func:create_graph()
            bv:show_graph_report("Entry Point CFG", graph)
        end
Function:
  description: |
    Represents a single function in the binary. Provides access to basic blocks, disassembly, variables, IL representations, and analysis metadata.
  properties:
    start_addr:
      type: HexAddress
      description: Start address of the function
      aliases:
      - start
    start:
      type: HexAddress
      description: Start address of the function (preferred name)
      example: print("Function starts at:", func.start)
    end_addr:
      type: HexAddress
      description: End address of the function (highest address in function)
      aliases:
      - end
      - highest_addr
    end:
      type: HexAddress
      description: End address of the function (use func["end"] since 'end' is a Lua keyword)
    size:
      type: integer
      description: Size of the function in bytes (end - start)
      example: print("Function size:", func.size, "bytes")
    name:
      type: string
      description: Display name of the function
      example: print("Analyzing:", func.name)
    arch:
      type: string
      description: Architecture name for this function (e.g., "x86_64", "thumb2")
      example: print("Architecture:", func.arch)
    comment:
      type: string
      description: Function-level comment
      example: |
        if func.comment ~= "" then
            print("Comment:", func.comment)
        end
    symbol:
      type: Symbol|nil
      description: Symbol associated with this function (may be nil for unnamed functions)
      example: |
        if func.symbol then
            print("Symbol:", func.symbol.name)
        end
    view:
      type: BinaryView
      description: BinaryView containing this function
      example: |
        local bv = func.view
        print("From file:", bv.file)
    auto_discovered:
      type: boolean
      description: Whether this function was auto-discovered by analysis (vs user-defined)
    has_user_annotations:
      type: boolean
      description: Whether the function has any user-added annotations
    is_pure:
      type: boolean
      description: Whether this function is marked as pure (no side effects, result depends only on inputs)
    has_explicitly_defined_type:
      type: boolean
      description: Whether the function signature was explicitly defined by user or type library
    has_user_type:
      type: boolean
      description: Whether the function has a user-defined type signature
    has_unresolved_indirect_branches:
      type: boolean
      description: Whether the function has indirect jumps/calls that couldn't be resolved
    analysis_skipped:
      type: boolean
      description: Whether analysis was skipped for this function
    too_large:
      type: boolean
      description: Whether the function was considered too large for full analysis
    needs_update:
      type: boolean
      description: Whether the function's analysis is out of date and needs re-analysis
    analysis_skip_reason:
      type: string
      description: Human-readable reason why analysis was skipped (if applicable)
    can_return:
      type: boolean
      description: Whether the function can return normally (false for noreturn functions)
      example: |
        if not func.can_return then
            print("This is a noreturn function")
        end
    auto:
      type: boolean
      description: Whether this function was auto-discovered during analysis (same as auto_discovered)
      example: |
        if func.auto then print("Auto-discovered function") end
    is_exported:
      type: boolean
      description: Whether this function is exported (visible in the binary's export table)
      example: |
        for _, f in ipairs(bv:functions()) do
            if f.is_exported then print("Exported:", f.name) end
        end
    is_inlined_during_analysis:
      type: boolean
      description: Whether this function is marked to be inlined during analysis
      example: |
        if func.is_inlined_during_analysis then
            print("Function will be inlined")
        end
    is_thunk:
      type: boolean
      description: Whether this is a thunk function (simple jump to another function)
      example: |
        if func.is_thunk then
            print("This is a thunk/stub function")
        end
    stack_adjustment:
      type: integer
      description: Stack adjustment made by this function in bytes
  methods:
    basic_blocks:
      description: Get all basic blocks in this function
      returns: table<BasicBlock>
      example: |
        local blocks = func:basic_blocks()
        print("Function has", #blocks, "basic blocks")
        for i, bb in ipairs(blocks) do
            print(string.format("  Block %d: %s - %s", i, bb.start_addr, bb.end_addr))
        end
    calls:
      description: Get all call instructions in this function as address/target pairs
      returns: 'table<{addr: HexAddress, target: HexAddress}>'
      example: |
        for _, call in ipairs(func:calls()) do
            print("Call at", call.addr, "to", call.target)
        end
    callers:
      description: Get all functions that call this function
      returns: table<Function>
      example: |
        local callers = func:callers()
        print("Called by", #callers, "functions:")
        for _, f in ipairs(callers) do print("  ", f.name) end
    call_sites:
      description: Get all locations within this function where calls are made
      returns: 'table<{address: HexAddress, func: Function|nil}>'
      example: |
        for _, site in ipairs(func:call_sites()) do
            print("Call at:", site.address)
        end
    callees:
      description: Get all functions that this function calls
      returns: table<Function>
      example: |
        local callees = func:callees()
        print("Calls", #callees, "functions:")
        for _, f in ipairs(callees) do print("  ", f.name) end
    callee_addresses:
      description: Get addresses of all functions called by this function
      returns: table<HexAddress>
      example: |
        for _, addr in ipairs(func:callee_addresses()) do
            print("Calls:", addr)
        end
    caller_sites:
      description: Get all call sites that call this function
      returns: 'table<{address: HexAddress, func: Function|nil, arch: string|nil}>'
      example: |
        local sites = func:caller_sites()
        print("Called from", #sites, "locations")
    variables:
      description: Get all variables in the function (parameters and locals)
      returns: table<Variable>
      example: |
        for _, var in ipairs(func:variables()) do
            print(var.name, var.type_name, var.source_type)
        end
    parameter_vars:
      description: Get only parameter variables
      returns: table<Variable>
      example: |
        print("Parameters:")
        for i, p in ipairs(func:parameter_vars()) do
            print(string.format("  %d. %s: %s", i, p.name, p.type_name))
        end
    clobbered_regs:
      description: Get registers that are clobbered (modified) by this function
      returns: table<string>
      example: |
        print("Clobbered registers:", table.concat(func:clobbered_regs(), ", "))
    get_variable_by_name:
      description: Look up a variable by name
      returns: Variable|nil
      params:
      - name: name
        type: string
        description: Variable name to look up
      example: |
        local arg0 = func:get_variable_by_name("arg0")
        if arg0 then print("Found:", arg0.type_name) end
    create_user_var:
      description: Create a new user-defined variable
      returns: boolean
      params:
      - name: storage
        type: integer
        description: Storage location (register number or stack offset)
      - name: typeStr
        type: string
        description: Type string for the variable
      - name: name
        type: string
        description: Name for the variable
    delete_user_var:
      description: Delete a user-defined variable
      params:
      - name: var
        type: Variable
        description: Variable to delete
    comment_at_address:
      description: Get the comment at a specific address within this function
      returns: string
      params:
      - name: addr
        type: integer
        description: Address to get comment for
    set_comment:
      description: Set the function-level comment
      returns: boolean
      params:
      - name: comment
        type: string
        description: Comment text (empty to remove)
      example: |
        func:set_comment("Main entry point - initializes subsystems")
    set_comment_at_address:
      description: Set a comment at a specific address within this function
      returns: boolean
      params:
      - name: addr
        type: integer
        description: Address to set comment at
      - name: comment
        type: string
        description: Comment text (empty to remove)
    set_name:
      description: Rename the function
      returns: boolean
      params:
      - name: name
        type: string
        description: New name for the function
      example: |
        func:set_name("initialize_crypto")
    set_return_type:
      description: Set the function's return type
      returns: boolean
      params:
      - name: type_str
        type: string
        description: C-style return type (e.g., "int", "void*", "struct foo*")
      example: |
        func:set_return_type("int64_t")
    set_parameter_type:
      description: Change the type of a function parameter
      returns: boolean
      params:
      - name: index
        type: integer
        description: Parameter index (0-based)
      - name: type_str
        type: string
        description: New type string
      example: |
        func:set_parameter_type(0, "const char*")
    set_parameter_name:
      description: Rename a function parameter
      returns: boolean
      params:
      - name: index
        type: integer
        description: Parameter index (0-based)
      - name: name
        type: string
        description: New parameter name
      example: |
        func:set_parameter_name(0, "filename")
        func:set_parameter_name(1, "mode")
    add_parameter:
      description: Add a new parameter to the function signature
      returns: boolean
      params:
      - name: type_str
        type: string
        description: Type string for the new parameter
      - name: name
        type: string
        description: (optional) Name for the new parameter
      example: |
        func:add_parameter("void*", "user_context")
    remove_parameter:
      description: Remove a parameter from the function signature
      returns: boolean
      params:
      - name: index
        type: integer
        description: Index of parameter to remove (0-based)
      example: |
        func:remove_parameter(2)  -- Remove third parameter
    set_calling_convention:
      description: Set the function's calling convention
      returns: boolean
      params:
      - name: ccName
        type: string
        description: Calling convention name (e.g., "cdecl", "stdcall", "fastcall")
      - name: reanalyze
        type: boolean
        description: (optional) Whether to trigger re-analysis after change
      example: |
        func:set_calling_convention("stdcall", true)
    set_can_return:
      description: Mark whether the function can return
      params:
      - name: canReturn
        type: boolean
        description: True if function returns, false for noreturn
      - name: reanalyze
        type: boolean
        description: (optional) Whether to trigger re-analysis
      example: |
        func:set_can_return(false)  -- Mark as noreturn
    set_has_variable_arguments:
      description: Mark whether the function accepts variable arguments (varargs)
      params:
      - name: hasVarArgs
        type: boolean
        description: True if function is variadic (like printf)
      - name: reanalyze
        type: boolean
        description: (optional) Whether to trigger re-analysis
    set_is_pure:
      description: Mark whether the function is pure (no side effects)
      params:
      - name: isPure
        type: boolean
        description: True if function is pure
      - name: reanalyze
        type: boolean
        description: (optional) Whether to trigger re-analysis
    set_analysis_skipped:
      description: Skip or unskip analysis for this function
      params:
      - name: skip
        type: boolean
        description: True to skip analysis, false to enable
    set_user_inlined:
      description: Mark the function to be inlined during analysis at call sites
      params:
      - name: inlined
        type: boolean
        description: True to inline this function, false to disable inlining
      - name: reanalyze
        type: boolean
        description: (optional, default false) Whether to trigger re-analysis after change
      example: |
        -- Mark small utility function to be inlined
        func:set_user_inlined(true, true)
    reanalyze:
      description: Trigger re-analysis of this function
      example: |
        func:set_return_type("int")
        func:reanalyze()
    mark_updates_required:
      description: Mark that this function needs re-analysis on next analysis pass
    get_llil:
      description: Get the Low Level IL representation of this function
      returns: LowLevelILFunction|nil
      example: |
        local llil = func:get_llil()
        if llil then
            print("LLIL instructions:", llil.instruction_count)
        end
    get_mlil:
      description: Get the Medium Level IL representation of this function
      returns: MediumLevelILFunction|nil
      example: |
        local mlil = func:get_mlil()
        if mlil then
            print("MLIL instructions:", mlil.instruction_count)
        end
    get_hlil:
      description: Get the High Level IL representation of this function
      returns: HighLevelILFunction|nil
      example: |
        local hlil = func:get_hlil()
        if hlil then
            print("HLIL instructions:", hlil.instruction_count)
        end
    type:
      description: Get detailed function type information
      returns: 'table<{return_type: string, parameters: table, calling_convention: string|nil}>'
      example: |
        local ft = func:type()
        print("Returns:", ft.return_type)
        for i, p in ipairs(ft.parameters) do
            print(string.format("  Param %d: %s %s", i, p.type, p.name or ""))
        end
    disassembly:
      description: Get full disassembly of the function
      returns: 'table<{addr: HexAddress, text: string}>'
      example: |
        for _, line in ipairs(func:disassembly()) do
            print(string.format("%s: %s", line.addr, line.text))
        end
    control_flow_graph:
      description: Get control flow graph data for visualization
      returns: 'table<{blocks: table, edges: table}>'
    stack_layout:
      description: Get the stack frame layout
      returns: 'table<{offset: integer, name: string, type: string}>'
      example: |
        for _, var in ipairs(func:stack_layout()) do
            print(string.format("[%+d] %s: %s", var.offset, var.name, var.type))
        end
    merged_vars:
      description: Get merged variable groups from SSA analysis
      returns: 'table<{target: Variable, sources: table<Variable>}>'
      example: |
        for _, group in ipairs(func:merged_vars()) do
            print("Merged into:", group.target.name)
            for _, src in ipairs(group.sources) do
                print("  from:", src.name)
            end
        end
    split_vars:
      description: Get variables that have been split by SSA analysis
      returns: table<Variable>
    split_variable:
      description: Mark a variable to be split for better analysis
      params:
      - name: var
        type: Variable
        description: Variable to split
    get_mlil_var_refs:
      description: Get all references to a variable in the Medium Level IL
      returns: 'table<{address: HexAddress, index: integer}>'
      params:
      - name: var
        type: Variable
        description: Variable to find references for
      example: |
        local var = func:variables()[1]
        local refs = func:get_mlil_var_refs(var)
        for _, ref in ipairs(refs) do
            print("MLIL ref at:", ref.address, "index:", ref.index)
        end
    get_hlil_var_refs:
      description: Get all references to a variable in the High Level IL
      returns: 'table<{address: HexAddress, index: integer}>'
      params:
      - name: var
        type: Variable
        description: Variable to find references for
      example: |
        local var = func:variables()[1]
        local refs = func:get_hlil_var_refs(var)
        for _, ref in ipairs(refs) do
            print("HLIL ref at:", ref.address, "index:", ref.index)
        end
    get_tags:
      description: Get all tags associated with this function
      returns: table<Tag>
    get_tags_at:
      description: Get tags at a specific address within this function
      returns: table<Tag>
      params:
      - name: addr
        type: integer
        description: Address to get tags at
    add_tag:
      description: Add a tag at an address within this function
      params:
      - name: addr
        type: integer
        description: Address to add tag at
      - name: tag
        type: Tag
        description: Tag to add
      - name: user
        type: boolean
        description: (optional) Whether this is a user tag
    remove_tag:
      description: Remove a tag from an address within this function
      params:
      - name: addr
        type: integer
        description: Address to remove tag from
      - name: tag
        type: Tag
        description: Tag to remove
      - name: user
        type: boolean
        description: (optional) Whether this is a user tag
    create_user_tag:
      description: Create and add a tag at an address within this function
      returns: Tag
      params:
      - name: addr
        type: integer
        description: Address to create tag at
      - name: tagTypeName
        type: string
        description: Name of the tag type
      - name: data
        type: string
        description: Tag data/description
    store_metadata:
      description: Store a value in the function's metadata database. Supports booleans, strings, integers, doubles, and tables.
      params:
      - name: key
        type: string
        description: Unique key to store the value under
      - name: value
        type: any
        description: Value to store (boolean, string, integer, number, or table)
      - name: isAuto
        type: boolean
        description: (optional, default false) If true, mark as auto-generated (not user-defined)
      example: |
        func:store_metadata("analyzed_by", "my_script")
        func:store_metadata("complexity", {blocks = 10, edges = 15})
    query_metadata:
      description: Retrieve a previously stored metadata value from this function
      returns: any|nil
      params:
      - name: key
        type: string
        description: Key to look up
      example: |
        local analyzer = func:query_metadata("analyzed_by")
        if analyzer then print("Analyzed by:", analyzer) end
    remove_metadata:
      description: Remove a metadata key and its value from the function
      params:
      - name: key
        type: string
        description: Key to remove
      example: |
        func:remove_metadata("temp_analysis_data")
    create_graph:
      description: Create a control flow graph for this function
      returns: FlowGraph
      params:
      - name: type
        type: string
        description: (optional) Graph type - "normal", "llil", "mlil", or "hlil" (default "normal")
      example: |
        local graph = func:create_graph()
        bv:show_graph_report("CFG", graph)

        -- Create HLIL graph
        local hlil_graph = func:create_graph("hlil")
        bv:show_graph_report("HLIL CFG", hlil_graph)
    create_graph_immediate:
      description: Create a control flow graph and wait for layout to complete before returning
      returns: FlowGraph
      params:
      - name: type
        type: string
        description: (optional) Graph type - "normal", "llil", "mlil", or "hlil" (default "normal")
      example: |
        -- Get graph with layout already computed
        local graph = func:create_graph_immediate()
        print("Graph size:", graph.width, "x", graph.height)
BasicBlock:
  description: |
    Represents a basic block within a function. A basic block is a sequence of instructions with a single entry point and single exit point - execution enters at the top and exits at the bottom, with no branches in between.
  properties:
    start_addr:
      type: HexAddress
      description: Start address of the basic block
      example: print("Block starts at:", bb.start_addr)
    end_addr:
      type: HexAddress
      description: End address of the basic block (address after last instruction)
      example: print("Block ends at:", bb.end_addr)
    length:
      type: integer
      description: Size of the basic block in bytes
      example: print("Block size:", bb.length, "bytes")
    index:
      type: integer
      description: Index of this block within the function's block list
    function:
      type: Function
      description: Function containing this basic block
      example: print("In function:", bb.function.name)
    arch:
      type: string
      description: Architecture name for this block
    can_exit:
      type: boolean
      description: Whether this block can cause the function to return
      example: |
        if bb.can_exit then print("Exit block") end
    has_undetermined_outgoing_edges:
      type: boolean
      description: Whether the block has unresolved indirect jumps
    has_invalid_instructions:
      type: boolean
      description: Whether the block contains instructions that failed to disassemble
    is_il:
      type: boolean
      description: Whether this is an IL basic block (vs native disassembly)
    is_llil:
      type: boolean
      description: Whether this is a Low Level IL basic block
    is_mlil:
      type: boolean
      description: Whether this is a Medium Level IL basic block
  methods:
    instruction_count:
      description: Get the number of instructions in this block
      returns: integer
      example: print("Instructions:", bb:instruction_count())
    outgoing_edges:
      description: Get edges to successor blocks
      returns: 'table<{target: BasicBlock, type: string, back_edge: boolean}>'
      example: |
        for _, edge in ipairs(bb:outgoing_edges()) do
            print("->", edge.target.start_addr, "type:", edge.type)
        end
    incoming_edges:
      description: Get edges from predecessor blocks
      returns: 'table<{source: BasicBlock, type: string, back_edge: boolean}>'
      example: |
        for _, edge in ipairs(bb:incoming_edges()) do
            print("<-", edge.source.start_addr)
        end
    dominators:
      description: Get all blocks that dominate this block (must be executed before this block)
      returns: table<BasicBlock>
      example: |
        print("Dominated by", #bb:dominators(), "blocks")
    strict_dominators:
      description: Get dominators excluding the block itself
      returns: table<BasicBlock>
    immediate_dominator:
      description: Get the immediate dominator (closest dominating block)
      returns: BasicBlock|nil
      example: |
        local idom = bb:immediate_dominator()
        if idom then print("Immediate dominator:", idom.start_addr) end
    dominator_tree_children:
      description: Get blocks that this block immediately dominates
      returns: table<BasicBlock>
    dominance_frontier:
      description: Get the dominance frontier (where dominance ends)
      returns: table<BasicBlock>
    post_dominators:
      description: Get all blocks that post-dominate this block (must be executed after this block)
      returns: table<BasicBlock>
    strict_post_dominators:
      description: Get post-dominators excluding the block itself
      returns: table<BasicBlock>
    immediate_post_dominator:
      description: Get the immediate post-dominator
      returns: BasicBlock|nil
    post_dominator_tree_children:
      description: Get blocks that this block immediately post-dominates
      returns: table<BasicBlock>
    post_dominance_frontier:
      description: Get the post-dominance frontier
      returns: table<BasicBlock>
    dominates:
      description: Check if this block dominates another block
      returns: boolean
      example: |
        if entry_block:dominates(bb) then
            print("Entry dominates this block")
        end
    strictly_dominates:
      description: Check if this block strictly dominates another (excluding itself)
      returns: boolean
    post_dominates:
      description: Check if this block post-dominates another block
      returns: boolean
    disassembly_text:
      description: Get raw disassembly text lines
      returns: table<string>
    disassembly:
      description: Get structured disassembly with addresses and tokens
      returns: 'table<{addr: HexAddress, text: string, tokens: table}>'
      example: |
        for _, line in ipairs(bb:disassembly()) do
            print(string.format("%s: %s", line.addr, line.text))
        end
    instructions:
      description: Get all instructions in this block as Instruction objects
      returns: table<Instruction>
      example: |
        for _, instr in ipairs(bb:instructions()) do
            print(instr.address, instr.mnemonic, instr.text)
        end
Instruction:
  description: |
    Represents a single disassembled instruction. Provides access to the instruction's address, mnemonic, operands, raw bytes, and references.
  properties:
    address:
      type: HexAddress
      description: Address of the instruction
      example: print("Instruction at:", instr.address)
    mnemonic:
      type: string
      description: Instruction mnemonic (e.g., "mov", "call", "jmp")
      example: |
        if instr.mnemonic == "call" then
            print("Found call instruction")
        end
    length:
      type: integer
      description: Size of the instruction in bytes
      example: print("Instruction is", instr.length, "bytes")
    text:
      type: string
      description: Full disassembly text including operands
      example: print(instr.text)  -- e.g., "mov eax, [rbp-0x8]"
    arch:
      type: string
      description: Architecture of the instruction
  methods:
    operands:
      description: Get the instruction's operands as strings
      returns: table<string>
      example: |
        for i, op in ipairs(instr:operands()) do
            print("Operand", i, ":", op)
        end
    bytes:
      description: Get the raw bytes of the instruction
      returns: string
      example: |
        local bytes = instr:bytes()
        local hex = ""
        for i = 1, #bytes do
            hex = hex .. string.format("%02x ", bytes:byte(i))
        end
        print("Bytes:", hex)
    references:
      description: Get addresses referenced by this instruction
      returns: table<HexAddress>
      example: |
        for _, ref in ipairs(instr:references()) do
            print("References:", ref)
        end
Variable:
  description: |
    Represents a variable within a function, including both parameters and local variables. Variables have names, types, and storage locations.
  properties:
    name:
      type: string
      description: Name of the variable
      example: print("Variable:", var.name)
    type:
      type: string
      description: Type name of the variable (e.g., "int", "char*")
      example: print(var.name, ":", var.type)
      aliases:
      - type_name
    type_name:
      type: string
      description: Alias for type property
    index:
      type: integer
      description: Variable index within the function
    source_type:
      type: string
      description: Source of the variable - "parameter", "local", or "unknown"
      example: |
        if var.source_type == "parameter" then
            print(var.name, "is a parameter")
        end
  methods:
    location:
      description: Get the storage location of the variable
      returns: 'table<{type: string, register: string|nil, offset: integer|nil}>'
      example: |
        local loc = var:location()
        if loc.register then
            print("In register:", loc.register)
        elseif loc.offset then
            print("Stack offset:", loc.offset)
        end
    set_name:
      description: Rename the variable
      returns: boolean
      params:
      - name: name
        type: string
        description: New name for the variable
      example: |
        var:set_name("buffer_ptr")
    set_type:
      description: Change the variable's type
      returns: boolean
      params:
      - name: typeStr
        type: string
        description: New type string (e.g., "uint32_t", "struct foo*")
      example: |
        var:set_type("char*")
Llil:
  description: |
    Low Level IL (LLIL) function representation. LLIL is Binary Ninja's first level of intermediate representation, closely modeling the original assembly but with a consistent instruction set across architectures.
  properties:
    instruction_count:
      type: integer
      description: Number of LLIL instructions in the function
      example: print("LLIL instructions:", llil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the LLIL
      example: print("LLIL blocks:", llil.basic_block_count)
  methods:
    get_function:
      description: Get the native function this LLIL belongs to
      returns: Function
      example: |
        local func = llil:get_function()
        print("LLIL for:", func.name)
    instruction_at:
      description: Get an LLIL instruction by index
      returns: LLILInstruction
      params:
      - name: index
        type: integer
        description: Instruction index (0-based)
      example: |
        for i = 0, llil.instruction_count - 1 do
            local instr = llil:instruction_at(i)
            print(i, llil:get_text(i))
        end
    get_text:
      description: Get the text representation of an LLIL instruction
      returns: string
      params:
      - name: index
        type: integer
        description: Instruction index (0-based)
      example: |
        print(llil:get_text(0))  -- First LLIL instruction
    create_graph:
      description: Create a flow graph for this LLIL function
      returns: FlowGraph
      example: |
        local graph = llil:create_graph()
        bv:show_graph_report("LLIL Graph", graph)
    create_graph_immediate:
      description: Create a flow graph and wait for layout to complete
      returns: FlowGraph
Mlil:
  description: |
    Medium Level IL (MLIL) function representation. MLIL lifts LLIL to a higher level, introducing typed variables, eliminating stack operations, and simplifying control flow.
  properties:
    instruction_count:
      type: integer
      description: Number of MLIL instructions in the function
      example: print("MLIL instructions:", mlil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the MLIL
      example: print("MLIL blocks:", mlil.basic_block_count)
  methods:
    get_function:
      description: Get the native function this MLIL belongs to
      returns: Function
    instruction_at:
      description: Get an MLIL instruction by index
      returns: MLILInstruction
      params:
      - name: index
        type: integer
        description: Instruction index (0-based)
    get_text:
      description: Get the text representation of an MLIL instruction
      returns: string
      params:
      - name: index
        type: integer
        description: Instruction index (0-based)
      example: |
        for i = 0, mlil.instruction_count - 1 do
            print(mlil:get_text(i))
        end
    create_graph:
      description: Create a flow graph for this MLIL function
      returns: FlowGraph
      example: |
        local graph = mlil:create_graph()
        bv:show_graph_report("MLIL Graph", graph)
    create_graph_immediate:
      description: Create a flow graph and wait for layout to complete
      returns: FlowGraph
Hlil:
  description: |
    High Level IL (HLIL) function representation. HLIL is the highest level IR, featuring structured control flow (if/while/for), compound expressions, and a representation close to source code.
  properties:
    instruction_count:
      type: integer
      description: Number of HLIL statements in the function
      example: print("HLIL statements:", hlil.instruction_count)
    basic_block_count:
      type: integer
      description: Number of basic blocks in the HLIL
      example: print("HLIL blocks:", hlil.basic_block_count)
  methods:
    get_function:
      description: Get the native function this HLIL belongs to
      returns: Function
    instruction_at:
      description: Get an HLIL statement by index
      returns: HLILInstruction
      params:
      - name: index
        type: integer
        description: Statement index (0-based)
    get_text:
      description: Get the text representation of an HLIL statement
      returns: string
      params:
      - name: index
        type: integer
        description: Statement index (0-based)
      example: |
        print("HLIL decompilation:")
        for i = 0, hlil.instruction_count - 1 do
            print(hlil:get_text(i))
        end
    create_graph:
      description: Create a flow graph for this HLIL function
      returns: FlowGraph
      example: |
        local graph = hlil:create_graph()
        bv:show_graph_report("HLIL Graph", graph)
    create_graph_immediate:
      description: Create a flow graph and wait for layout to complete
      returns: FlowGraph
FlowGraph:
  description: |
    Represents a flow graph for visualizing control flow, call graphs, or custom graph structures. Can be displayed using bv:show_graph_report().
  constructor:
    description: Create a new empty FlowGraph
    example: |
      local graph = FlowGraph.new()
  properties:
    width:
      type: integer
      description: Width of the graph after layout (0 if layout not complete)
      example: |
        local graph = func:create_graph_immediate()
        print("Graph width:", graph.width)
    height:
      type: integer
      description: Height of the graph after layout (0 if layout not complete)
    node_count:
      type: integer
      description: Number of nodes in the graph
      example: print("Nodes:", graph.node_count)
    has_nodes:
      type: boolean
      description: Whether the graph has any nodes
    function:
      type: Function|nil
      description: Associated function (if this is a function graph)
    view:
      type: BinaryView|nil
      description: Associated BinaryView (if any)
    is_il:
      type: boolean
      description: Whether this is an IL graph (vs disassembly)
    is_llil:
      type: boolean
      description: Whether this is an LLIL graph
    is_mlil:
      type: boolean
      description: Whether this is an MLIL graph
    is_hlil:
      type: boolean
      description: Whether this is an HLIL graph
  methods:
    nodes:
      description: Get all nodes in the graph
      returns: table<FlowGraphNode>
      example: |
        for _, node in ipairs(graph:nodes()) do
            print("Node at:", node.x, node.y)
        end
    get_node:
      description: Get a node by its index
      returns: FlowGraphNode|nil
      params:
      - name: index
        type: integer
        description: Node index (0-based)
    add_node:
      description: Add a node to the graph
      params:
      - name: node
        type: FlowGraphNode
        description: Node to add
    create_node:
      description: Create and add a new node to the graph
      returns: FlowGraphNode
      example: |
        local node = graph:create_node()
        node:set_lines({"Block A", "  instruction 1"})
    clear_nodes:
      description: Remove all nodes from the graph
FlowGraphNode:
  description: |
    Represents a single node in a FlowGraph. Contains display lines and edge connections to other nodes.
  constructor:
    description: Create a new FlowGraphNode for a graph
    params:
    - name: graph
      type: FlowGraph
      description: The graph this node will belong to
    example: |
      local node = FlowGraphNode.new(graph)
      node:set_lines({"Entry", "  mov eax, 1"})
      graph:add_node(node)
  properties:
    x:
      type: integer
      description: X position after layout
    y:
      type: integer
      description: Y position after layout
    width:
      type: integer
      description: Width of the node
    height:
      type: integer
      description: Height of the node
    basic_block:
      type: BasicBlock|nil
      description: Associated BasicBlock (if this node represents one)
    highlight:
      type: table
      description: Highlight color as {r, g, b, a} (0-255 values)
  methods:
    lines:
      description: Get the text lines displayed in this node
      returns: table<string>
    set_lines:
      description: Set the text lines displayed in this node
      params:
      - name: lines
        type: table<string>
        description: Array of text lines to display
      example: |
        node:set_lines({"Block header", "  mov eax, 1", "  ret"})
    outgoing_edges:
      description: Get all edges from this node to other nodes
      returns: 'table<{type: string, target: FlowGraphNode, back_edge: boolean}>'
      example: |
        for _, edge in ipairs(node:outgoing_edges()) do
            print("Edge type:", edge.type, "to node at", edge.target.x)
        end
    incoming_edges:
      description: Get all edges from other nodes to this node
      returns: 'table<{type: string, source: FlowGraphNode, back_edge: boolean}>'
    add_outgoing_edge:
      description: Add an edge from this node to another node
      params:
      - name: type
        type: string
        description: Edge type - "UnconditionalBranch", "TrueBranch", "FalseBranch", "CallDestination", etc.
      - name: target
        type: FlowGraphNode
        description: Target node for the edge
      example: |
        node1:add_outgoing_edge("TrueBranch", node2)
        node1:add_outgoing_edge("FalseBranch", node3)
DataVariable:
  description: |
    Represents a data variable (global variable, constant, or data structure) defined in the binary.
  properties:
    address:
      type: HexAddress
      description: Address where the data variable is located
      example: print("Variable at:", var.address)
    type:
      type: string
      description: Type of the data variable as a string (e.g., "int32_t", "char*")
      example: print("Type:", var.type)
    name:
      type: string
      description: Symbol name of the variable (empty string if no symbol)
      example: |
        if var.name ~= "" then
            print("Named:", var.name)
        end
    auto_discovered:
      type: boolean
      description: Whether this variable was auto-discovered during analysis (vs user-defined)
      example: |
        if var.auto_discovered then
            print("Auto-discovered variable")
        end
    type_confidence:
      type: integer
      description: Confidence level of the type assignment (0-255, higher is more confident)
TagType:
  description: |
    Represents a type/category of tag that can be applied to addresses. Tag types define the name, icon, and visibility of tags.
  properties:
    id:
      type: string
      description: Unique identifier for the tag type
    name:
      type: string
      description: Display name of the tag type
      example: print("Tag type:", tagType.name)
    icon:
      type: string
      description: Icon/emoji displayed for this tag type
      example: print("Icon:", tagType.icon)
    visible:
      type: boolean
      description: Whether tags of this type are visible in the UI
    type:
      type: string
      description: Category of tag type - "user", "notification", or "bookmarks"
  methods:
    set_name:
      description: Change the tag type's display name
      params:
      - name: name
        type: string
        description: New name for the tag type
    set_icon:
      description: Change the tag type's icon
      params:
      - name: icon
        type: string
        description: New icon (single character/emoji)
    set_visible:
      description: Set whether tags of this type are visible
      params:
      - name: visible
        type: boolean
        description: True to show, false to hide
Tag:
  description: |
    Represents an individual tag instance applied at an address. Tags have a type (TagType) and optional data.
  properties:
    id:
      type: string
      description: Unique identifier for this tag instance
    type:
      type: TagType
      description: The TagType this tag belongs to
      example: print("Tag category:", tag.type.name)
    data:
      type: string
      description: Optional data/description stored with the tag
      example: |
        if tag.data ~= "" then
            print("Note:", tag.data)
        end
  methods:
    set_data:
      description: Update the tag's data/description
      params:
      - name: data
        type: string
        description: New data string for the tag
      example: |
        tag:set_data("Updated note about this location")
Type:
  description: |
    Represents a type in Binary Ninja's type system. Can represent primitives, pointers, arrays, structures, enumerations, and function types.
  properties:
    type_class:
      type: string
      description: Kind of type - "Void", "Bool", "Integer", "Float", "Structure", "Enumeration", "Pointer", "Array", "Function", etc.
      example: |
        if t.type_class == "Structure" then
            print("This is a struct")
        end
    type_class_value:
      type: integer
      description: Numeric type class for programmatic comparisons
    width:
      type: integer
      description: Size of the type in bytes
      example: print("Size:", t.width, "bytes")
    alignment:
      type: integer
      description: Alignment requirement in bytes
    name:
      type: string
      description: Name of the type (for named types)
    is_void:
      type: boolean
      description: Whether this is a void type
    is_bool:
      type: boolean
      description: Whether this is a boolean type
    is_integer:
      type: boolean
      description: Whether this is an integer type
    is_float:
      type: boolean
      description: Whether this is a floating-point type
    is_structure:
      type: boolean
      description: Whether this is a structure/class type
    is_enumeration:
      type: boolean
      description: Whether this is an enumeration type
    is_pointer:
      type: boolean
      description: Whether this is a pointer type
    is_array:
      type: boolean
      description: Whether this is an array type
    is_function:
      type: boolean
      description: Whether this is a function type
    is_signed:
      type: boolean
      description: Whether this is a signed integer type
    is_const:
      type: boolean
      description: Whether this type has const qualifier
    is_volatile:
      type: boolean
      description: Whether this type has volatile qualifier
    element_count:
      type: integer
      description: Number of elements (for array types, 0 otherwise)
    return_type:
      type: string
      description: Return type string (for function types)
    has_variable_arguments:
      type: boolean
      description: Whether function accepts variable arguments (for function types)
    can_return:
      type: boolean
      description: Whether function can return (false for noreturn, for function types)
  methods:
    target:
      description: Get the target type for pointer types
      returns: Type|nil
      example: |
        if t.is_pointer then
            local target = t:target()
            if target then print("Points to:", target:get_string()) end
        end
    members:
      description: Get structure members (for structure types only)
      returns: 'table<{name: string, offset: integer, type: string, width: integer, access: string}>|nil'
      example: |
        if t.is_structure then
            for _, m in ipairs(t:members()) do
                print(string.format("+0x%x %s: %s", m.offset, m.name, m.type))
            end
        end
    get_member_by_name:
      description: Get a structure member by name
      returns: 'table<{name, offset, type, width, access}>|nil'
      params:
      - name: name
        type: string
        description: Member name to look up
    get_member_at_offset:
      description: Get a structure member at a specific offset
      returns: 'table<{name, offset, type, width, access}>|nil'
      params:
      - name: offset
        type: integer
        description: Byte offset within the structure
    enum_members:
      description: Get enumeration members (for enum types only)
      returns: 'table<{name: string, value: integer, is_default: boolean}>|nil'
      example: |
        if t.is_enumeration then
            for _, m in ipairs(t:enum_members()) do
                print(m.name, "=", m.value)
            end
        end
    parameters:
      description: Get function parameters (for function types only)
      returns: 'table<{name: string, type: string, has_default: boolean}>|nil'
      example: |
        if t.is_function then
            print("Parameters:")
            for i, p in ipairs(t:parameters()) do
                print(i, p.name, p.type)
            end
        end
    get_string:
      description: Get the full type declaration as a string
      returns: string
      example: |
        print("Full type:", t:get_string())
GlobalFunctions:
  description: |
    Global utility functions available without a receiver object.
  functions:
    markdown_to_html:
      description: Convert markdown text to HTML
      returns: string
      params:
      - name: markdown
        type: string
        description: Markdown text to convert
      example: |
        local md = "# Title\n\nSome **bold** text"
        local html = markdown_to_html(md)
        print(html)
