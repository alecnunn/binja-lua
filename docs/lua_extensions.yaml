# Lua Extension API definitions
# Generated by docs/extract_lua_extensions.py
# These are optional & experimental extensions

_meta:
  title: Lua Extension APIs
  description: Optional & experimental Lua extensions for binja-lua
  status: experimental
collections:
  description: Idiomatic Lua collection APIs and iterators for Binary Ninja
  source: lua-api/collections.lua
  methods:
    BinaryView:
      each_function:
        description: Iterate over all functions in the binary
        returns:
          type: function
          description: Iterator function that yields Function objects
        example: |-
          for func in bv:each_function() do
                  print(func.name, func.size)
              end
      each_section:
        description: Iterate over all sections in the binary
        returns:
          type: function
          description: Iterator function that yields Section objects
        example: |-
          for section in bv:each_section() do
                  print(section.name, section.start_addr)
              end
      functions_collection:
        description: Get a fluent collection wrapper for all functions
        returns:
          type: Collection
          description: Collection of Function objects
        example: |-
          local large_funcs = bv:functions_collection()
                  :filter(function(f) return f.size > 1000 end)
                  :sort(function(a, b) return a.size > b.size end)
      sections_collection:
        description: Get a fluent collection wrapper for all sections
        returns:
          type: Collection
          description: Collection of Section objects
      each_tag:
        description: Iterate over all tags in the binary
        returns:
          type: function
          description: Iterator function that yields Tag objects
        example: |-
          for tag in bv:each_tag() do
                  print(tag.type.name, tag.data)
              end
      tags_collection:
        description: Get a fluent collection wrapper for all tags
        returns:
          type: Collection
          description: Collection of Tag objects
        example: |-
          local important_tags = bv:tags_collection()
                  :filter(function(t) return t.type.name == "Important" end)
      types_collection:
        description: Get a fluent collection wrapper for all defined types
        returns:
          type: Collection
          description: Collection of {name, type} entries
        example: |-
          local structs = bv:types_collection()
                  :filter(function(t) return t.type.is_structure end)
      each_type:
        description: Iterate over all defined types in the binary
        returns:
          type: function
          description: Iterator function that yields {name, type} entries
        example: |-
          for entry in bv:each_type() do
                  print(entry.name, entry.type.type_class)
              end
      each_data_var:
        description: Iterate over all data variables in the binary
        returns:
          type: function
          description: Iterator function that yields DataVariable objects
        example: |-
          for dv in bv:each_data_var() do
                  print(string.format("0x%x: %s", dv.address.value, dv.type))
              end
      data_vars_collection:
        description: Get a fluent collection wrapper for all data variables
        returns:
          type: Collection
          description: Collection of DataVariable objects
    Function:
      each_basic_block:
        description: Iterate over all basic blocks in the function
        returns:
          type: function
          description: Iterator function that yields BasicBlock objects
        example: |-
          for block in func:each_basic_block() do
                  print(string.format("Block at 0x%x", block.start_addr))
              end
      each_caller:
        description: Iterate over all functions that call this function
        returns:
          type: function
          description: Iterator function that yields Function objects
        example: |-
          for caller in func:each_caller() do
                  print("Called by:", caller.name)
              end
      each_call:
        description: Iterate over all functions called by this function
        returns:
          type: function
          description: Iterator function that yields Function objects
        example: |-
          for called_func in func:each_call() do
                  print("Calls:", called_func.name)
              end
      basic_blocks_collection:
        description: Get a fluent collection wrapper for basic blocks
        returns:
          type: Collection
          description: Collection of BasicBlock objects
      callers_collection:
        description: Get a fluent collection wrapper for caller functions
        returns:
          type: Collection
          description: Collection of Function objects
      calls_collection:
        description: Get a fluent collection wrapper for called functions
        returns:
          type: Collection
          description: Collection of Function objects
      each_variable:
        description: Iterate over all variables in the function
        returns:
          type: function
          description: Iterator function that yields Variable objects
        example: |-
          for var in func:each_variable() do
                  print(var.name, var.type)
              end
      variables_collection:
        description: Get a fluent collection wrapper for all variables
        returns:
          type: Collection
          description: Collection of Variable objects
        example: |-
          local stack_vars = func:variables_collection()
                  :filter(function(v) return v.source_type == "stack" end)
      each_clobbered_reg:
        description: Iterate over registers clobbered by this function
        returns:
          type: function
          description: Iterator function that yields register names
        example: |-
          for reg in func:each_clobbered_reg() do
                  print("Clobbers:", reg)
              end
      each_tag:
        description: Iterate over all tags attached to this function
        returns:
          type: function
          description: Iterator function that yields Tag objects
        example: |-
          for tag in func:each_tag() do
                  print(tag.type.name, tag.data)
              end
      tags_collection:
        description: Get a fluent collection wrapper for function tags
        returns:
          type: Collection
          description: Collection of Tag objects
fluent:
  description: Advanced fluent API patterns for Binary Ninja analysis
  source: lua-api/fluent.lua
  methods:
    Query:
      new:
        description: Create a new Query instance
        returns:
          type: Query
          description: New query instance
      functions:
        description: Start a query with all functions in the binary
        returns:
          type: Query
          description: Self for method chaining
        example: local all_functions = bv:query():functions():get()
      at_address:
        description: Filter to only the function at the specified address
        returns:
          type: Query
          description: Self for method chaining
        example: local func_at_addr = bv:query():at_address(0x10001000):get()
      with_name:
        description: Filter functions by name pattern (Lua pattern matching)
        returns:
          type: Query
          description: Self for method chaining
        example: local main_funcs = bv:query():functions():with_name("main.*"):get()
      larger_than:
        description: Filter functions larger than specified size in bytes
        returns:
          type: Query
          description: Self for method chaining
        example: local large_funcs = bv:query():functions():larger_than(1000):get()
      with_calls_to:
        description: Filter functions that call functions matching the pattern
        returns:
          type: Query
          description: Self for method chaining
        example: local malloc_callers = bv:query():functions():with_calls_to("malloc"):get()
      exported_only:
        description: Filter to only exported functions
        returns:
          type: Query
          description: Self for method chaining
        example: local exports = bv:query():functions():exported_only():get()
      auto_discovered:
        description: Filter to only auto-discovered (not user-defined) functions
        returns:
          type: Query
          description: Self for method chaining
        example: local auto_funcs = bv:query():functions():auto_discovered():get()
      user_defined:
        description: Filter to only user-defined (not auto-discovered) functions
        returns:
          type: Query
          description: Self for method chaining
        example: local user_funcs = bv:query():functions():user_defined():get()
      thunks_only:
        description: Filter to only thunk functions
        returns:
          type: Query
          description: Self for method chaining
        example: local thunks = bv:query():functions():thunks_only():get()
      exclude_thunks:
        description: Filter out thunk functions
        returns:
          type: Query
          description: Self for method chaining
        example: local real_funcs = bv:query():functions():exclude_thunks():get()
      pure_only:
        description: Filter to only pure functions (no side effects)
        returns:
          type: Query
          description: Self for method chaining
        example: local pure_funcs = bv:query():functions():pure_only():get()
      with_stack_adjustment:
        description: Filter to functions with non-zero stack adjustment
        returns:
          type: Query
          description: Self for method chaining
        example: local stack_funcs = bv:query():functions():with_stack_adjustment():get()
      with_variables:
        description: Filter to functions that have variables
        returns:
          type: Query
          description: Self for method chaining
        example: local funcs_with_vars = bv:query():functions():with_variables():get()
      with_tags:
        description: Filter to functions that have tags attached
        returns:
          type: Query
          description: Self for method chaining
        example: local tagged_funcs = bv:query():functions():with_tags():get()
      sort_by:
        description: Sort results by a key function
        returns:
          type: Query
          description: Self for method chaining
        example: local sorted_by_size = bv:query():functions():sort_by(function(f) return f.size end, true):get()
      limit:
        description: Limit results to first N items
        returns:
          type: Query
          description: Self for method chaining
        example: local top_10 = bv:query():functions():sort_by(function(f) return f.size end, true):limit(10):get()
      execute:
        description: Execute the query and return results
        returns:
          type: table
          description: Array of results from the query
      get:
        description: Convenience method to execute the query (alias for execute)
        returns:
          type: table
          description: Array of results from the query
        example: local results = bv:query():functions():larger_than(100):get()
    Analysis:
      function_classification:
        description: Classify all functions by type (thunk, exported, auto, pure, etc.)
        returns:
          type: table
          description: Statistics about function classifications
        example: |-
          local class = bv:analyze():function_classification()
          print("Exported:", class.exported)
          print("Thunks:", class.thunks)
          print("Auto-discovered:", class.auto_discovered)
      tag_report:
        description: Generate statistics about tags in the binary
        returns:
          type: table
          description: Statistics about tags and tag types
        example: |-
          local tags = bv:analyze():tag_report()
          print("Total tags:", tags.total_tags)
          for type_name, count in pairs(tags.by_type) do
              print(type_name, count)
          end
      stack_analysis:
        description: Analyze stack usage across all functions
        returns:
          type: table
          description: Statistics about stack adjustments
        example: |-
          local stacks = bv:analyze():stack_analysis()
          print("Max stack:", stacks.max_adjustment)
          print("Average:", stacks.average_adjustment)
      variable_analysis:
        description: Analyze variable usage across all functions
        returns:
          type: table
          description: Statistics about variables
        example: |-
          local vars = bv:analyze():variable_analysis()
          print("Total variables:", vars.total_variables)
          print("Functions with vars:", vars.functions_with_variables)
      type_analysis:
        description: Analyze defined types in the binary
        returns:
          type: table
          description: Statistics about types
        example: |-
          local types = bv:analyze():type_analysis()
          print("Structures:", types.structures)
          print("Enumerations:", types.enumerations)
    BinaryView:
      query:
        description: Create a fluent query builder for complex analysis workflows
        returns:
          type: Query
          description: Query builder instance for chaining operations
        example: |-
          local large_functions = bv:query()
                  :functions()
                  :larger_than(1000)
                  :with_calls_to("malloc")
                  :sort_by(function(f) return f.size end, true)
                  :limit(10)
                  :get()
      analyze:
        description: Create an analysis helper for common analysis patterns
        returns:
          type: Analysis
          description: Analysis helper instance with pre-built workflows
        example: |-
          local connectivity = bv:analyze():connectivity_report()
              local size_stats = bv:analyze():size_analysis()
init:
  description: Auto-initialization module that loads and initializes all Lua extensions
  source: lua-api/init.lua
  methods: {}
utils:
  description: Enhanced utility functions for debugging and data inspection
  source: lua-api/utils.lua
  methods:
    utils:
      find_functions_by_name_pattern:
        description: Find all functions whose names match a Lua pattern
        returns:
          type: table
          description: Array of Function objects matching the pattern
        example: |-
          local crypto_funcs = utils.find_functions_by_name_pattern(bv, ".*crypt.*")
          for _, func in ipairs(crypto_funcs) do
              print("Found crypto function:", func.name)
          end
      find_functions_by_size_range:
        description: Find functions within a specific size range
        returns:
          type: table
          description: Array of Function objects within the size range
        example: |-
          local small_funcs = utils.find_functions_by_size_range(bv, 1, 50)
          local large_funcs = utils.find_functions_by_size_range(bv, 1000)
      get_call_depth:
        description: Calculate the maximum call depth from a function (recursive calls)
        returns:
          type: integer
          description: Maximum call depth from this function
        example: |-
          local depth = utils.get_call_depth(main_func)
          print(string.format("Max call depth from %s: %d", main_func.name, depth))
      find_strings_in_function:
        description: Find string references within a function that match a pattern
        returns:
          type: table
          description: Array of {address, string} tables for matching strings
        example: |-
          local api_strings = utils.find_strings_in_function(func, ".*API.*")
          for _, str_ref in ipairs(api_strings) do
              print(string.format("API string at 0x%x: %s", str_ref.address, str_ref.string))
          end
      get_function_complexity:
        description: Calculate basic complexity metrics for a function
        returns:
          type: table
          description: 'Table with complexity metrics: {blocks, edges, cyclomatic}'
        example: |-
          local complexity = utils.get_function_complexity(func)
          print(string.format("Function %s: %d blocks, cyclomatic complexity: %d",
              func.name, complexity.blocks, complexity.cyclomatic))
      get_imports_used_by_function:
        description: Get all imported functions referenced by a specific function
        returns:
          type: table
          description: Array of import symbol names used by this function
        example: |-
          local imports = utils.get_imports_used_by_function(func)
          for _, import_name in ipairs(imports) do
              print("Function uses import:", import_name)
          end
      init:
        description: Initialize the utilities module and extend Binary Ninja objects
        example: |-
          local utils = require('utils')
          utils.init()
    global:
      dump:
        description: Recursively format any Lua value with clean, readable output
        returns:
          type: string
          description: Formatted string representation of the value
        example: |-
          local data = {name="test", values={1,2,3}, nested={a=1}}
          print(dump(data))
          -- Compact format
          print(dump(data, {compact=true}))
          -- Show array indices
          print(dump({func1, func2}, {show_indices=true}))
